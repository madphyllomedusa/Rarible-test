"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorFromName = exports.errorFromCode = exports.InstructionMismatchError = exports.ReceiptIsEmptyError = exports.TradeStateIsNotEmptyError = exports.TradeStateDoesntExistError = exports.InvalidBasisPointsError = exports.NoValidSignerPresentError = exports.BuyerATACannotHaveDelegateError = exports.SellerATACannotHaveDelegateError = exports.OldSellerNotInitializedError = exports.SaleRequiresSignerError = exports.CannotMatchFreeSalesWithoutAuctionHouseOrSellerSignoffError = exports.BothPartiesNeedToAgreeToSaleError = exports.InvalidTokenAmountError = exports.MetadataDoesntExistError = exports.DerivedKeyInvalidError = exports.NoPayerPresentError = exports.CannotTakeThisActionWithoutAuctionHouseSignOffError = exports.SOLWalletMustSignError = exports.CannotExchangeSOLForSolError = exports.ExpectedSolAccountError = exports.NumericalOverflowError = exports.NotRentExemptError = exports.StatementFalseError = exports.PublicKeysShouldBeUniqueError = exports.IncorrectOwnerError = exports.UninitializedAccountError = exports.InvalidMintAuthorityError = exports.PublicKeyMismatchError = void 0;
const createErrorFromCodeLookup = new Map();
const createErrorFromNameLookup = new Map();
class PublicKeyMismatchError extends Error {
    constructor() {
        super('PublicKeyMismatch');
        this.code = 0x1770;
        this.name = 'PublicKeyMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PublicKeyMismatchError);
        }
    }
}
exports.PublicKeyMismatchError = PublicKeyMismatchError;
createErrorFromCodeLookup.set(0x1770, () => new PublicKeyMismatchError());
createErrorFromNameLookup.set('PublicKeyMismatch', () => new PublicKeyMismatchError());
class InvalidMintAuthorityError extends Error {
    constructor() {
        super('InvalidMintAuthority');
        this.code = 0x1771;
        this.name = 'InvalidMintAuthority';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidMintAuthorityError);
        }
    }
}
exports.InvalidMintAuthorityError = InvalidMintAuthorityError;
createErrorFromCodeLookup.set(0x1771, () => new InvalidMintAuthorityError());
createErrorFromNameLookup.set('InvalidMintAuthority', () => new InvalidMintAuthorityError());
class UninitializedAccountError extends Error {
    constructor() {
        super('UninitializedAccount');
        this.code = 0x1772;
        this.name = 'UninitializedAccount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, UninitializedAccountError);
        }
    }
}
exports.UninitializedAccountError = UninitializedAccountError;
createErrorFromCodeLookup.set(0x1772, () => new UninitializedAccountError());
createErrorFromNameLookup.set('UninitializedAccount', () => new UninitializedAccountError());
class IncorrectOwnerError extends Error {
    constructor() {
        super('IncorrectOwner');
        this.code = 0x1773;
        this.name = 'IncorrectOwner';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, IncorrectOwnerError);
        }
    }
}
exports.IncorrectOwnerError = IncorrectOwnerError;
createErrorFromCodeLookup.set(0x1773, () => new IncorrectOwnerError());
createErrorFromNameLookup.set('IncorrectOwner', () => new IncorrectOwnerError());
class PublicKeysShouldBeUniqueError extends Error {
    constructor() {
        super('PublicKeysShouldBeUnique');
        this.code = 0x1774;
        this.name = 'PublicKeysShouldBeUnique';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, PublicKeysShouldBeUniqueError);
        }
    }
}
exports.PublicKeysShouldBeUniqueError = PublicKeysShouldBeUniqueError;
createErrorFromCodeLookup.set(0x1774, () => new PublicKeysShouldBeUniqueError());
createErrorFromNameLookup.set('PublicKeysShouldBeUnique', () => new PublicKeysShouldBeUniqueError());
class StatementFalseError extends Error {
    constructor() {
        super('StatementFalse');
        this.code = 0x1775;
        this.name = 'StatementFalse';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, StatementFalseError);
        }
    }
}
exports.StatementFalseError = StatementFalseError;
createErrorFromCodeLookup.set(0x1775, () => new StatementFalseError());
createErrorFromNameLookup.set('StatementFalse', () => new StatementFalseError());
class NotRentExemptError extends Error {
    constructor() {
        super('NotRentExempt');
        this.code = 0x1776;
        this.name = 'NotRentExempt';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NotRentExemptError);
        }
    }
}
exports.NotRentExemptError = NotRentExemptError;
createErrorFromCodeLookup.set(0x1776, () => new NotRentExemptError());
createErrorFromNameLookup.set('NotRentExempt', () => new NotRentExemptError());
class NumericalOverflowError extends Error {
    constructor() {
        super('NumericalOverflow');
        this.code = 0x1777;
        this.name = 'NumericalOverflow';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NumericalOverflowError);
        }
    }
}
exports.NumericalOverflowError = NumericalOverflowError;
createErrorFromCodeLookup.set(0x1777, () => new NumericalOverflowError());
createErrorFromNameLookup.set('NumericalOverflow', () => new NumericalOverflowError());
class ExpectedSolAccountError extends Error {
    constructor() {
        super('Expected a sol account but got an spl token account instead');
        this.code = 0x1778;
        this.name = 'ExpectedSolAccount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ExpectedSolAccountError);
        }
    }
}
exports.ExpectedSolAccountError = ExpectedSolAccountError;
createErrorFromCodeLookup.set(0x1778, () => new ExpectedSolAccountError());
createErrorFromNameLookup.set('ExpectedSolAccount', () => new ExpectedSolAccountError());
class CannotExchangeSOLForSolError extends Error {
    constructor() {
        super('Cannot exchange sol for sol');
        this.code = 0x1779;
        this.name = 'CannotExchangeSOLForSol';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CannotExchangeSOLForSolError);
        }
    }
}
exports.CannotExchangeSOLForSolError = CannotExchangeSOLForSolError;
createErrorFromCodeLookup.set(0x1779, () => new CannotExchangeSOLForSolError());
createErrorFromNameLookup.set('CannotExchangeSOLForSol', () => new CannotExchangeSOLForSolError());
class SOLWalletMustSignError extends Error {
    constructor() {
        super('If paying with sol, sol wallet must be signer');
        this.code = 0x177a;
        this.name = 'SOLWalletMustSign';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, SOLWalletMustSignError);
        }
    }
}
exports.SOLWalletMustSignError = SOLWalletMustSignError;
createErrorFromCodeLookup.set(0x177a, () => new SOLWalletMustSignError());
createErrorFromNameLookup.set('SOLWalletMustSign', () => new SOLWalletMustSignError());
class CannotTakeThisActionWithoutAuctionHouseSignOffError extends Error {
    constructor() {
        super('Cannot take this action without auction house signing too');
        this.code = 0x177b;
        this.name = 'CannotTakeThisActionWithoutAuctionHouseSignOff';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CannotTakeThisActionWithoutAuctionHouseSignOffError);
        }
    }
}
exports.CannotTakeThisActionWithoutAuctionHouseSignOffError = CannotTakeThisActionWithoutAuctionHouseSignOffError;
createErrorFromCodeLookup.set(0x177b, () => new CannotTakeThisActionWithoutAuctionHouseSignOffError());
createErrorFromNameLookup.set('CannotTakeThisActionWithoutAuctionHouseSignOff', () => new CannotTakeThisActionWithoutAuctionHouseSignOffError());
class NoPayerPresentError extends Error {
    constructor() {
        super('No payer present on this txn');
        this.code = 0x177c;
        this.name = 'NoPayerPresent';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NoPayerPresentError);
        }
    }
}
exports.NoPayerPresentError = NoPayerPresentError;
createErrorFromCodeLookup.set(0x177c, () => new NoPayerPresentError());
createErrorFromNameLookup.set('NoPayerPresent', () => new NoPayerPresentError());
class DerivedKeyInvalidError extends Error {
    constructor() {
        super('Derived key invalid');
        this.code = 0x177d;
        this.name = 'DerivedKeyInvalid';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, DerivedKeyInvalidError);
        }
    }
}
exports.DerivedKeyInvalidError = DerivedKeyInvalidError;
createErrorFromCodeLookup.set(0x177d, () => new DerivedKeyInvalidError());
createErrorFromNameLookup.set('DerivedKeyInvalid', () => new DerivedKeyInvalidError());
class MetadataDoesntExistError extends Error {
    constructor() {
        super("Metadata doesn't exist");
        this.code = 0x177e;
        this.name = 'MetadataDoesntExist';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, MetadataDoesntExistError);
        }
    }
}
exports.MetadataDoesntExistError = MetadataDoesntExistError;
createErrorFromCodeLookup.set(0x177e, () => new MetadataDoesntExistError());
createErrorFromNameLookup.set('MetadataDoesntExist', () => new MetadataDoesntExistError());
class InvalidTokenAmountError extends Error {
    constructor() {
        super('Invalid token amount');
        this.code = 0x177f;
        this.name = 'InvalidTokenAmount';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidTokenAmountError);
        }
    }
}
exports.InvalidTokenAmountError = InvalidTokenAmountError;
createErrorFromCodeLookup.set(0x177f, () => new InvalidTokenAmountError());
createErrorFromNameLookup.set('InvalidTokenAmount', () => new InvalidTokenAmountError());
class BothPartiesNeedToAgreeToSaleError extends Error {
    constructor() {
        super('Both parties need to agree to this sale');
        this.code = 0x1780;
        this.name = 'BothPartiesNeedToAgreeToSale';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, BothPartiesNeedToAgreeToSaleError);
        }
    }
}
exports.BothPartiesNeedToAgreeToSaleError = BothPartiesNeedToAgreeToSaleError;
createErrorFromCodeLookup.set(0x1780, () => new BothPartiesNeedToAgreeToSaleError());
createErrorFromNameLookup.set('BothPartiesNeedToAgreeToSale', () => new BothPartiesNeedToAgreeToSaleError());
class CannotMatchFreeSalesWithoutAuctionHouseOrSellerSignoffError extends Error {
    constructor() {
        super('Cannot match free sales unless the auction house or seller signs off');
        this.code = 0x1781;
        this.name = 'CannotMatchFreeSalesWithoutAuctionHouseOrSellerSignoff';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, CannotMatchFreeSalesWithoutAuctionHouseOrSellerSignoffError);
        }
    }
}
exports.CannotMatchFreeSalesWithoutAuctionHouseOrSellerSignoffError = CannotMatchFreeSalesWithoutAuctionHouseOrSellerSignoffError;
createErrorFromCodeLookup.set(0x1781, () => new CannotMatchFreeSalesWithoutAuctionHouseOrSellerSignoffError());
createErrorFromNameLookup.set('CannotMatchFreeSalesWithoutAuctionHouseOrSellerSignoff', () => new CannotMatchFreeSalesWithoutAuctionHouseOrSellerSignoffError());
class SaleRequiresSignerError extends Error {
    constructor() {
        super('This sale requires a signer');
        this.code = 0x1782;
        this.name = 'SaleRequiresSigner';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, SaleRequiresSignerError);
        }
    }
}
exports.SaleRequiresSignerError = SaleRequiresSignerError;
createErrorFromCodeLookup.set(0x1782, () => new SaleRequiresSignerError());
createErrorFromNameLookup.set('SaleRequiresSigner', () => new SaleRequiresSignerError());
class OldSellerNotInitializedError extends Error {
    constructor() {
        super('Old seller not initialized');
        this.code = 0x1783;
        this.name = 'OldSellerNotInitialized';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, OldSellerNotInitializedError);
        }
    }
}
exports.OldSellerNotInitializedError = OldSellerNotInitializedError;
createErrorFromCodeLookup.set(0x1783, () => new OldSellerNotInitializedError());
createErrorFromNameLookup.set('OldSellerNotInitialized', () => new OldSellerNotInitializedError());
class SellerATACannotHaveDelegateError extends Error {
    constructor() {
        super('Seller ata cannot have a delegate set');
        this.code = 0x1784;
        this.name = 'SellerATACannotHaveDelegate';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, SellerATACannotHaveDelegateError);
        }
    }
}
exports.SellerATACannotHaveDelegateError = SellerATACannotHaveDelegateError;
createErrorFromCodeLookup.set(0x1784, () => new SellerATACannotHaveDelegateError());
createErrorFromNameLookup.set('SellerATACannotHaveDelegate', () => new SellerATACannotHaveDelegateError());
class BuyerATACannotHaveDelegateError extends Error {
    constructor() {
        super('Buyer ata cannot have a delegate set');
        this.code = 0x1785;
        this.name = 'BuyerATACannotHaveDelegate';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, BuyerATACannotHaveDelegateError);
        }
    }
}
exports.BuyerATACannotHaveDelegateError = BuyerATACannotHaveDelegateError;
createErrorFromCodeLookup.set(0x1785, () => new BuyerATACannotHaveDelegateError());
createErrorFromNameLookup.set('BuyerATACannotHaveDelegate', () => new BuyerATACannotHaveDelegateError());
class NoValidSignerPresentError extends Error {
    constructor() {
        super('No valid signer present');
        this.code = 0x1786;
        this.name = 'NoValidSignerPresent';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, NoValidSignerPresentError);
        }
    }
}
exports.NoValidSignerPresentError = NoValidSignerPresentError;
createErrorFromCodeLookup.set(0x1786, () => new NoValidSignerPresentError());
createErrorFromNameLookup.set('NoValidSignerPresent', () => new NoValidSignerPresentError());
class InvalidBasisPointsError extends Error {
    constructor() {
        super('BP must be less than or equal to 10000');
        this.code = 0x1787;
        this.name = 'InvalidBasisPoints';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InvalidBasisPointsError);
        }
    }
}
exports.InvalidBasisPointsError = InvalidBasisPointsError;
createErrorFromCodeLookup.set(0x1787, () => new InvalidBasisPointsError());
createErrorFromNameLookup.set('InvalidBasisPoints', () => new InvalidBasisPointsError());
class TradeStateDoesntExistError extends Error {
    constructor() {
        super('The trade state account does not exist');
        this.code = 0x1788;
        this.name = 'TradeStateDoesntExist';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, TradeStateDoesntExistError);
        }
    }
}
exports.TradeStateDoesntExistError = TradeStateDoesntExistError;
createErrorFromCodeLookup.set(0x1788, () => new TradeStateDoesntExistError());
createErrorFromNameLookup.set('TradeStateDoesntExist', () => new TradeStateDoesntExistError());
class TradeStateIsNotEmptyError extends Error {
    constructor() {
        super('The trade state is not empty');
        this.code = 0x1789;
        this.name = 'TradeStateIsNotEmpty';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, TradeStateIsNotEmptyError);
        }
    }
}
exports.TradeStateIsNotEmptyError = TradeStateIsNotEmptyError;
createErrorFromCodeLookup.set(0x1789, () => new TradeStateIsNotEmptyError());
createErrorFromNameLookup.set('TradeStateIsNotEmpty', () => new TradeStateIsNotEmptyError());
class ReceiptIsEmptyError extends Error {
    constructor() {
        super('The receipt is empty');
        this.code = 0x178a;
        this.name = 'ReceiptIsEmpty';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, ReceiptIsEmptyError);
        }
    }
}
exports.ReceiptIsEmptyError = ReceiptIsEmptyError;
createErrorFromCodeLookup.set(0x178a, () => new ReceiptIsEmptyError());
createErrorFromNameLookup.set('ReceiptIsEmpty', () => new ReceiptIsEmptyError());
class InstructionMismatchError extends Error {
    constructor() {
        super('The instruction does not match');
        this.code = 0x178b;
        this.name = 'InstructionMismatch';
        if (typeof Error.captureStackTrace === 'function') {
            Error.captureStackTrace(this, InstructionMismatchError);
        }
    }
}
exports.InstructionMismatchError = InstructionMismatchError;
createErrorFromCodeLookup.set(0x178b, () => new InstructionMismatchError());
createErrorFromNameLookup.set('InstructionMismatch', () => new InstructionMismatchError());
function errorFromCode(code) {
    const createError = createErrorFromCodeLookup.get(code);
    return createError != null ? createError() : null;
}
exports.errorFromCode = errorFromCode;
function errorFromName(name) {
    const createError = createErrorFromNameLookup.get(name);
    return createError != null ? createError() : null;
}
exports.errorFromName = errorFromName;
//# sourceMappingURL=index.js.map