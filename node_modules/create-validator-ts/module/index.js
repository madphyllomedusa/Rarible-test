import globWatch from "glob-watcher";
import _fs from "fs";
import * as globby from "globby";
import assert from "assert";
import { generateValidator } from "./create-validator-ts";
import path from "path";
// TODO: Node 14+
const fs = _fs.promises;
export async function watchValidator(options) {
    const { generator, generatorOptions = {} } = (await import(path.resolve(options.cwd, options.codeGeneratorScript)));
    const watcher = globWatch(options.targetGlobs, {
        ignoreInitial: true
    });
    return new Promise((resolve, reject) => {
        watcher.on("change", async (filePath) => {
            const result = await generateValidator({
                cwd: options.cwd,
                filePath: filePath,
                tsconfigFilePath: options.tsconfigFilePath,
                validatorGenerator: generator,
                extraTags: generatorOptions.extraTags || []
            });
            if (!result) {
                return;
            }
            if (options.verbose) {
                console.log("Update validator: " + result.validatorFilePath);
            }
            return fs.writeFile(result.validatorFilePath, result.code, "utf-8");
        });
        watcher.on("close", () => {
            resolve();
        });
        watcher.on("error", (error) => {
            reject(error);
        });
    });
}
// --check: validate the difference current of source
export async function testGeneratedValidator(options) {
    const files = globby.sync(options.targetGlobs, {
        cwd: options.cwd,
        absolute: true
    });
    const { generator, generatorOptions = {} } = (await import(path.resolve(options.cwd, options.codeGeneratorScript)));
    return Promise.all(files.map(async (filePath) => {
        const result = await generateValidator({
            cwd: options.cwd,
            filePath: filePath,
            tsconfigFilePath: options.tsconfigFilePath,
            validatorGenerator: generator,
            extraTags: generatorOptions.extraTags || []
        });
        if (!result) {
            return;
        }
        try {
            await fs.access(result.validatorFilePath);
        }
        catch (_a) {
            return;
        }
        const oldValidatorCode = await fs.readFile(result.validatorFilePath, "utf-8");
        try {
            assert.strictEqual(oldValidatorCode, result.code);
        }
        catch (error) {
            console.error("Found diff between types and validator.\nPlease update validator: $ npx create-validator-ts " +
                filePath);
            throw error;
        }
        if (options.verbose) {
            console.log("OK: " + filePath);
        }
    }));
}
export async function createValidator(options) {
    const { generator, generatorOptions = {} } = (await import(path.resolve(options.cwd, options.codeGeneratorScript)));
    const files = globby.sync(options.targetGlobs, {
        cwd: options.cwd,
        absolute: true
    });
    return Promise.all(files.map(async (filePath) => {
        const result = await generateValidator({
            cwd: options.cwd,
            filePath: filePath,
            tsconfigFilePath: options.tsconfigFilePath,
            validatorGenerator: generator,
            extraTags: generatorOptions.extraTags || []
        });
        if (!result) {
            return;
        }
        if (options.verbose) {
            console.log("Create: " + filePath);
        }
        return fs.writeFile(result.validatorFilePath, result.code, "utf-8");
    }));
}
//# sourceMappingURL=index.js.map