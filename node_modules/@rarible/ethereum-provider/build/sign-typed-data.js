"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signTypedData = void 0;
var tslib_1 = require("tslib");
var eth_sig_util_1 = require("eth-sig-util");
var domain_1 = require("./domain");
function signTypedData(send, signer, data) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var error_1, error_2;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 8]);
                    return [4 /*yield*/, send(domain_1.SignTypedDataMethodEnum.V4, [signer, JSON.stringify(data)])];
                case 1: return [2 /*return*/, _a.sent()];
                case 2:
                    error_1 = _a.sent();
                    console.error("got error while executing sign typed data v4", error_1);
                    if (!(isError(error_1) && error_1.message === "MetaMask Message Signature: Error: Not supported on this device")) return [3 /*break*/, 3];
                    return [2 /*return*/, signWithHardwareWallets(send, signer, data)];
                case 3:
                    filterErrors(error_1);
                    _a.label = 4;
                case 4:
                    _a.trys.push([4, 6, , 7]);
                    return [4 /*yield*/, send(domain_1.SignTypedDataMethodEnum.V3, [signer, JSON.stringify(data)])];
                case 5: return [2 /*return*/, _a.sent()];
                case 6:
                    error_2 = _a.sent();
                    console.error("got error while executing sign typed data v3", error_2);
                    filterErrors(error_2);
                    return [2 /*return*/, send(domain_1.SignTypedDataMethodEnum.DEFAULT, [signer, data])];
                case 7: return [3 /*break*/, 8];
                case 8: return [2 /*return*/];
            }
        });
    });
}
exports.signTypedData = signTypedData;
function isError(x) {
    return typeof x === "object" && x !== null && "message" in x;
}
function signWithHardwareWallets(send, signer, data) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var hash, signature, _a;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    hash = eth_sig_util_1.TypedDataUtils.sign(data);
                    _a = toBuffer;
                    return [4 /*yield*/, send("eth_sign", [signer, "0x".concat(hash.toString("hex"))])];
                case 1:
                    signature = _a.apply(void 0, [_b.sent()]);
                    signature.writeInt8(signature[64] + 4, 64);
                    return [2 /*return*/, "0x".concat(signature.toString("hex"))];
            }
        });
    });
}
/*
    4900 - wallet is disconnected
    4001 - user cancelled request
    4901 - chain is not connected
    4100 - not authorized in wallet
*/
function filterErrors(original) {
    if (hasCode(original)) {
        if ([4900, 4001, 4901, 4100].includes(original.code)) {
            throw original;
        }
    }
}
function hasCode(error) {
    return typeof error === "object" && error !== null && "code" in error;
}
function toBuffer(hex) {
    if (hex.startsWith("0x")) {
        return Buffer.from(hex.substring(2), "hex");
    }
    else {
        return Buffer.from(hex, "hex");
    }
}
