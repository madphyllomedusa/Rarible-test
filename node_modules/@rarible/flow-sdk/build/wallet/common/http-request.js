"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.httpRequest = void 0;
var tslib_1 = require("tslib");
var HTTPRequestError = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(HTTPRequestError, _super);
    function HTTPRequestError(_a) {
        var transport = _a.transport, error = _a.error, hostname = _a.hostname, path = _a.path, port = _a.port, method = _a.method, requestBody = _a.requestBody, responseBody = _a.responseBody, responseStatusText = _a.responseStatusText, reqOn = _a.reqOn;
        var _this = this;
        var msg = "\n      HTTP Request Error: An error occurred when interacting with the Access API.\n      transport=".concat(transport, "\n      error=").concat(error, "\n      hostname=").concat(hostname, "\n      path=").concat(path, "\n      port=").concat(port, "\n      method=").concat(method, "\n      requestBody=").concat(JSON.stringify(requestBody), "\n      responseBody=").concat(responseBody, "\n      responseStatusText=").concat(responseStatusText, "\n      reqOn=").concat(reqOn, "\n    ");
        _this = _super.call(this, msg) || this;
        _this.name = "HTTPRequestError";
        return _this;
    }
    return HTTPRequestError;
}(Error));
/**
 * Creates an HTTP Request to be sent to a REST Access API.
 *
 * Supports the Fetch API on Web Browsers and Deno.
 * Uses the Node HTTP(S) standard libraries for Node.
 *
 * @param {String} hostname - Access API Hostname
 * @param {String} path - Path to the resource on the Access API
 * @param {String} method - HTTP Method
 * @param {Object} body - HTTP Request Body
 *
 * @returns JSON object response from Access API.
 */
function httpRequest(_a) {
    var hostname = _a.hostname, path = _a.path, method = _a.method, body = _a.body;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var isHTTPs, fetchTransport, nodeHttpsTransport, e_1, nodeHttpTransport, e_2;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    isHTTPs = hostname.substring(0, 5) === "https";
                    try {
                        fetchTransport = (window === null || window === void 0 ? void 0 : window.fetch) || fetch;
                    }
                    catch (e) {
                    }
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, Promise.resolve().then(function () { return (0, tslib_1.__importStar)(require("https")); }).catch(function () { return undefined; })];
                case 2:
                    nodeHttpsTransport = _b.sent();
                    return [3 /*break*/, 4];
                case 3:
                    e_1 = _b.sent();
                    return [3 /*break*/, 4];
                case 4:
                    _b.trys.push([4, 6, , 7]);
                    return [4 /*yield*/, Promise.resolve().then(function () { return (0, tslib_1.__importStar)(require("http")); }).catch(function () { return undefined; })];
                case 5:
                    nodeHttpTransport = _b.sent();
                    return [3 /*break*/, 7];
                case 6:
                    e_2 = _b.sent();
                    return [3 /*break*/, 7];
                case 7:
                    if (!(fetchTransport || nodeHttpsTransport)) {
                        throw new Error("HTTP Request error: Could not find a supported HTTP module.");
                    }
                    if (!fetchTransport) return [3 /*break*/, 9];
                    return [4 /*yield*/, fetchTransport("".concat(hostname).concat(path), {
                            method: method,
                            body: body ? JSON.stringify(body) : undefined,
                        }).then(function (res) {
                            if (res.ok) {
                                return res.json();
                            }
                            throw new HTTPRequestError({
                                transport: "FetchTransport",
                                error: "",
                                hostname: hostname,
                                path: path,
                                method: method,
                                requestBody: body,
                                responseBody: res.json(),
                                responseStatusText: res.statusText,
                            });
                        }).catch(function (e) {
                            throw new HTTPRequestError({
                                transport: "FetchTransport",
                                error: e,
                                hostname: hostname,
                                path: path,
                                method: method,
                                requestBody: body,
                            });
                        })];
                case 8: return [2 /*return*/, _b.sent()];
                case 9:
                    if (nodeHttpsTransport && nodeHttpTransport) {
                        return [2 /*return*/, new Promise(function (resolve, reject) {
                                var hostnameParts = hostname.split(":");
                                var port = hostnameParts.length === 3 ? hostnameParts[2] : undefined;
                                var parsedHostname = hostnameParts.length > 1 ? hostnameParts[1].substring(2) : hostnameParts[0];
                                var transport = isHTTPs ? nodeHttpsTransport : nodeHttpTransport;
                                var bodyString = body ? JSON.stringify(body) : null;
                                var options = {
                                    hostname: parsedHostname,
                                    path: path,
                                    port: port,
                                    method: method,
                                    headers: body ? {
                                        "Content-Type": "application/json",
                                        "Content-Length": bodyString === null || bodyString === void 0 ? void 0 : bodyString.length,
                                    } : undefined,
                                };
                                var responseBody = [];
                                var req = transport.request(options, function (res) {
                                    res.setEncoding("utf8");
                                    res.on("data", function (dataChunk) {
                                        responseBody.push(dataChunk);
                                    });
                                    res.on("end", function () {
                                        try {
                                            responseBody = JSON.parse(responseBody.join(""));
                                        }
                                        catch (e) {
                                            reject(new HTTPRequestError({
                                                transport: isHTTPs ? "NodeHTTPsTransport" : "NodeHTTPTransport",
                                                error: e,
                                                hostname: parsedHostname,
                                                path: path,
                                                port: port,
                                                method: method,
                                                requestBody: body,
                                                responseBody: responseBody,
                                                reqOn: "end",
                                            }));
                                        }
                                        resolve(responseBody);
                                    });
                                });
                                req.on("error", function (e) {
                                    reject(new HTTPRequestError({
                                        transport: isHTTPs ? "NodeHTTPsTransport" : "NodeHTTPTransport",
                                        error: e,
                                        hostname: parsedHostname,
                                        path: path,
                                        port: port,
                                        method: method,
                                        requestBody: body,
                                        responseBody: responseBody,
                                        reqOn: "error",
                                    }));
                                });
                                if (body)
                                    req.write(bodyString);
                                req.end();
                            })];
                    }
                    _b.label = 10;
                case 10: return [2 /*return*/];
            }
        });
    });
}
exports.httpRequest = httpRequest;
