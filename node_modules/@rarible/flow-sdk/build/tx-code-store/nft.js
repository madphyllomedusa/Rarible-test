"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNftCode = void 0;
var tslib_1 = require("tslib");
var t = (0, tslib_1.__importStar)(require("@onflow/types"));
var flow_sdk_scripts_1 = require("@rarible/flow-sdk-scripts");
var convert_royalties_1 = require("../common/convert-royalties");
var cadence_code_config_1 = require("../config/cadence-code-config");
var types_1 = require("../types");
var template_replacer_1 = require("../common/template-replacer");
function getNftCode(name) {
    if (types_1.NON_FUNGIBLE_CONTRACTS.includes(name)) {
        var map_1 = (0, cadence_code_config_1.getNftCodeConfig)(name);
        return {
            burn: function (fcl, tokenId) {
                return {
                    cadence: (0, template_replacer_1.fillCodeTemplate)(flow_sdk_scripts_1.commonNft.burn, map_1),
                    args: fcl.args([fcl.arg(tokenId, t.UInt64)]),
                };
            },
            transfer: function (fcl, tokenId, to) {
                return {
                    cadence: (0, template_replacer_1.fillCodeTemplate)(flow_sdk_scripts_1.commonNft.transfer, map_1),
                    args: fcl.args([fcl.arg(tokenId, t.UInt64), fcl.arg(to, t.Address)]),
                };
            },
            mint: function (fcl, address, metadata, royalties) {
                if (name === "RaribleNFT") {
                    var RoyaltiesType = t.Array(t.Struct("A.".concat(fcl.sansPrefix(address), ".RaribleNFT.Royalty"), [
                        { value: t.Address },
                        { value: t.UFix64 },
                    ]));
                    return {
                        cadence: flow_sdk_scripts_1.RaribleNFT.mint,
                        args: fcl.args([
                            fcl.arg(metadata, t.String),
                            fcl.arg((0, convert_royalties_1.convertRoyalties)(royalties), RoyaltiesType),
                        ]),
                    };
                }
                throw new Error("This collection doesn't support minting");
            },
            check: function (fcl, address) {
                return {
                    cadence: (0, template_replacer_1.fillCodeTemplate)(flow_sdk_scripts_1.commonNft.check, map_1),
                    args: fcl.args([fcl.arg(address, t.Address)]),
                };
            },
            setupAccount: function () {
                return {
                    cadence: (0, template_replacer_1.fillCodeTemplate)(flow_sdk_scripts_1.commonNft.setupAccount, map_1),
                };
            },
        };
    }
    throw new Error("Flow-sdk: Unsupported collection: ".concat(name));
}
exports.getNftCode = getNftCode;
