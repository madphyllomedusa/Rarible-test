"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNftCodeConfig = exports.getFtCodeConfig = void 0;
var tslib_1 = require("tslib");
function getFtCodeConfig(contract) {
    var knownConf = {
        "%ftContract%": contract,
        "%ftPrivateType%": "FungibleToken.Provider,FungibleToken.Balance,FungibleToken.Receiver",
        "%ftPrivatePath%": "/private/".concat(contract, "_vaultRef"),
    };
    switch (contract) {
        case "FUSD":
            return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, knownConf), { "%ftPublicPath%": "/public/fusdReceiver", "%ftStoragePath%": "/storage/fusdVault" });
        case "FlowToken":
            return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, knownConf), { "%ftPublicPath%": "/public/flowTokenReceiver", "%ftStoragePath%": "/storage/flowTokenVault" });
        default:
            throw new Error("Unsupported fungible contract: ".concat(contract));
    }
}
exports.getFtCodeConfig = getFtCodeConfig;
var nftCodeConfig = {
    RaribleNFT: {
        "%nftPublicPath%": "RaribleNFT.collectionPublicPath",
        "%nftStoragePath%": "RaribleNFT.collectionStoragePath",
    },
    Evolution: {
        "%nftPublicPath%": "/public/f4264ac8f3256818_Evolution_Collection",
        "%nftStoragePath%": "/storage/f4264ac8f3256818_Evolution_Collection",
        "%publicTypeAddon%": "Evolution.EvolutionCollectionPublic",
    },
    MotoGPCard: {
        "%nftPublicPath%": "/public/motogpCardCollection",
        "%nftStoragePath%": "/storage/motogpCardCollection",
        "%publicTypeAddon%": "MotoGPCard.ICardCollectionPublic",
    },
    TopShot: {
        "%nftPublicPath%": "/public/MomentCollection",
        "%nftStoragePath%": "/storage/MomentCollection",
        "%publicTypeAddon%": "TopShot.MomentCollectionPublic",
    },
    MugenNFT: {
        "%nftPublicPath%": "MugenNFT.CollectionPublicPath",
        "%nftStoragePath%": "MugenNFT.CollectionStoragePath",
    },
    CNN_NFT: {
        "%nftPublicPath%": "CNN_NFT.CollectionPublicPath",
        "%nftStoragePath%": "CNN_NFT.CollectionStoragePath",
    },
    MatrixWorldFlowFestNFT: {
        "%nftPublicPath%": "MatrixWorldFlowFestNFT.CollectionPublicPath",
        "%nftStoragePath%": "MatrixWorldFlowFestNFT.CollectionStoragePath",
    },
    MatrixWorldVoucher: {
        "%nftPublicPath%": "MatrixWorldVoucher.CollectionPublicPath",
        "%nftStoragePath%": "MatrixWorldVoucher.CollectionStoragePath",
        "%publicTypeAddon%": "MatrixWorldVoucher.MatrixWorldVoucherCollectionPublic",
    },
    DisruptArt: {
        "%nftPublicPath%": "DisruptArt.disruptArtPublicPath",
        "%nftStoragePath%": "DisruptArt.disruptArtStoragePath",
    },
    Art: {
        "%nftPublicPath%": "Art.CollectionPublicPath",
        "%nftStoragePath%": "Art.CollectionStoragePath",
        "%publicTypeAddon%": "Art.CollectionPublic",
    },
    StarlyCard: {
        "%nftPublicPath%": "StarlyCard.CollectionPublicPath",
        "%nftStoragePath%": "StarlyCard.CollectionStoragePath",
        "%publicTypeAddon%": "StarlyCard.StarlyCardCollectionPublic",
    },
    OneFootballCollectible: {
        "%nftPublicPath%": "OneFootballCollectible.CollectionPublicPath",
        "%nftStoragePath%": "OneFootballCollectible.CollectionStoragePath",
        "%publicTypeAddon%": "OneFootballCollectible.OneFootballCollectibleCollectionPublic",
    },
    ChainmonstersRewards: {
        "%nftPublicPath%": "/public/ChainmonstersRewardCollection",
        "%nftStoragePath%": "/storage/ChainmonstersRewardCollection",
        "%publicTypeAddon%": "ChainmonstersRewards.ChainmonstersRewardCollectionPublic",
    },
    BarterYardPackNFT: {
        "%nftPublicPath%": "BarterYardPackNFT.CollectionPublicPath",
        "%nftStoragePath%": "BarterYardPackNFT.CollectionStoragePath",
        "%publicTypeAddon%": "BarterYardPackNFT.BarterYardPackNFTCollectionPublic",
    },
    FanfareNFTContract: {
        "%nftPublicPath%": "FanfareNFTContract.CollectionPublicPath",
        "%nftStoragePath%": "FanfareNFTContract.CollectionStoragePath",
        "%publicTypeAddon%": "FanfareNFTContract.FanfareNFTCollectionPublic",
    },
    Kicks: {
        "%nftPublicPath%": "Kicks.CollectionPublicPath",
        "%nftStoragePath%": "Kicks.CollectionStoragePath",
    },
    Moments: {
        "%nftPublicPath%": "Moments.CollectionPublicPath",
        "%nftStoragePath%": "Moments.CollectionStoragePath",
        "%publicTypeAddon%": "Moments.CollectionPublic",
    },
    SomePlaceCollectible: {
        "%nftPublicPath%": "SomePlaceCollectible.CollectionPublicPath",
        "%nftStoragePath%": "SomePlaceCollectible.CollectionStoragePath",
        "%publicTypeAddon%": "SomePlaceCollectible.CollectibleCollectionPublic",
    },
    IrNFT: {
        "%nftPublicPath%": "IrNFT.CollectionPublicPath",
        "%nftStoragePath%": "IrNFT.CollectionStoragePath",
        "%publicTypeAddon%": "IrNFT.CollectionPublic",
    },
    IrVoucher: {
        "%nftPublicPath%": "IrVoucher.CollectionPublicPath",
        "%nftStoragePath%": "IrVoucher.CollectionStoragePath",
        "%publicTypeAddon%": "IrVoucher.CollectionPublic",
    },
    GeniaceNFT: {
        "%nftPublicPath%": "GeniaceNFT.CollectionPublicPath",
        "%nftStoragePath%": "GeniaceNFT.CollectionStoragePath",
        "%publicTypeAddon%": "GeniaceNFT.GeniaceNFTCollectionPublic",
    },
    CryptoPiggo: {
        "%nftPublicPath%": "CryptoPiggo.CollectionPublicPath",
        "%nftStoragePath%": "CryptoPiggo.CollectionStoragePath",
        "%publicTypeAddon%": "CryptoPiggo.CryptoPiggoCollectionPublic",
    },
};
function getNftCodeConfig(contract) {
    if (!Object.keys(nftCodeConfig).includes(contract)) {
        throw new Error("Unsupported contract: ".concat(contract));
    }
    var staticConfig = nftCodeConfig[contract];
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, staticConfig), { "%nftContract%": contract, "%nftStorageType%": "".concat(contract, ".Collection"), "%nftPrivatePath%": "/private/".concat(contract, "_collectionRef"), "%nftPrivateType%": "NonFungibleToken.CollectionPublic,NonFungibleToken.Provider,NonFungibleToken.Receiver", "%nftPublicType%": "".concat(staticConfig["%publicTypeAddon%"] ? staticConfig["%publicTypeAddon%"] + "," : "", "NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver"), "%nftPublicTypeMin%": staticConfig["%publicTypeAddon%"] || "NonFungibleToken.CollectionPublic" });
}
exports.getNftCodeConfig = getNftCodeConfig;
