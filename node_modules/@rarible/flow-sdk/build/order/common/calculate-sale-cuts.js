"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.concatNonUniqueFees = exports.calculateSaleCuts = void 0;
var tslib_1 = require("tslib");
var utils_1 = require("@rarible/utils");
var types_1 = require("@rarible/types");
var prefix_1 = require("../../common/prefix");
/**
 * Gets fees in percents and convert to currency value
 * @param mainPayoutAddress - seller address
 * @param price - order price
 * @param fees - royalties, protocolFee, originFee
 * @param payouts - payoutFee
 * @returns FlowFee - calculated fees in currency
 */
function calculateSaleCuts(mainPayoutAddress, price, fees, payouts) {
    var startPrice = (0, utils_1.toBn)(price);
    var leftAfterFees = (0, utils_1.toBn)(price);
    var resultFeeSaleCuts = fees.map(function (fee) {
        var value = startPrice.multipliedBy((0, utils_1.toBn)(fee.value));
        leftAfterFees = leftAfterFees.minus(value);
        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, fee), { value: (0, types_1.toBigNumber)(value.decimalPlaces(8).toString()) });
    });
    var leftAfterPayouts = (0, utils_1.toBn)(leftAfterFees);
    var resultPayoutSaleCuts = payouts.map(function (fee) {
        var value = leftAfterFees.multipliedBy((0, utils_1.toBn)(fee.value));
        leftAfterPayouts = leftAfterPayouts.minus(value);
        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, fee), { value: (0, types_1.toBigNumber)(value.decimalPlaces(8).toString()) });
    });
    if (leftAfterPayouts.gt(0)) {
        resultPayoutSaleCuts.push({
            account: mainPayoutAddress,
            value: (0, types_1.toBigNumber)(leftAfterPayouts.decimalPlaces(8).toString()),
        });
    }
    else if (leftAfterPayouts.lt(0)) {
        throw new Error("Sum of payouts greater than price");
    }
    return concatNonUniqueFees((0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], resultFeeSaleCuts, true), resultPayoutSaleCuts, true));
}
exports.calculateSaleCuts = calculateSaleCuts;
function concatNonUniqueFees(fees) {
    var unique = {};
    fees.forEach(function (f) {
        var account = (0, prefix_1.withPrefix)(f.account);
        if (account in unique) {
            unique[account] = (0, utils_1.toBn)(unique[account]).plus((0, utils_1.toBn)(f.value)).toString();
        }
        else {
            unique[account] = f.value;
        }
    });
    return Object.keys(unique).map(function (k) { return ({ account: (0, types_1.toFlowAddress)(k), value: (0, types_1.toBigNumber)(unique[k]) }); });
}
exports.concatNonUniqueFees = concatNonUniqueFees;
