"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOrderDetailsFromBlockchain = void 0;
var tslib_1 = require("tslib");
var flow_sdk_scripts_1 = require("@rarible/flow-sdk-scripts");
var t = (0, tslib_1.__importStar)(require("@onflow/types"));
var types_1 = require("@rarible/types");
var transaction_1 = require("../../common/transaction");
var config_1 = require("../../config/config");
var prefix_1 = require("../../common/prefix");
function getOrderDetailsFromBlockchain(fcl, network, orderType, address, orderId) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var cadence, map, args, details, fungibleContract, protocolFeeReceiver, data;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    switch (orderType) {
                        case "sell":
                            cadence = flow_sdk_scripts_1.StorefrontCommon.read_listing_details;
                            map = {
                                NFTStorefront: config_1.CONFIGS[network].mainAddressMap.NFTStorefront,
                            };
                            break;
                        case "bid":
                            cadence = flow_sdk_scripts_1.openBidCommon.readBidDetails;
                            map = {
                                RaribleOpenBid: config_1.CONFIGS[network].mainAddressMap.RaribleOpenBid,
                            };
                            break;
                        default:
                            throw new Error("Unsupported order type");
                    }
                    args = fcl.args([fcl.arg(address, t.Address), fcl.arg(orderId, t.UInt64)]);
                    return [4 /*yield*/, (0, transaction_1.runScript)(fcl, {
                            cadence: cadence,
                            args: args,
                        }, map)];
                case 1:
                    details = _a.sent();
                    fungibleContract = "vaultType" in details ? details.vaultType.split(".")[2] : details.salePaymentVaultType.split(".")[2];
                    protocolFeeReceiver = config_1.CONFIGS[network].protocolFee.account;
                    data = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, details), { saleCuts: ("saleCuts" in details ? details.saleCuts : details.cuts).map(function (s) { return ({
                            account: (0, types_1.toFlowAddress)(s.receiver.address),
                            value: (0, types_1.toBigNumber)(s.amount),
                        }); }) });
                    data.isLegacy = data.saleCuts.filter(function (s) { return (0, prefix_1.withPrefix)(s.account).toLowerCase() === (0, prefix_1.withPrefix)(protocolFeeReceiver).toLowerCase(); }).length > 1;
                    switch (fungibleContract) {
                        case "FlowToken":
                            return [2 /*return*/, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, data), { currency: "FLOW" })];
                        case "FUSD":
                            return [2 /*return*/, (0, tslib_1.__assign)((0, tslib_1.__assign)({}, data), { currency: "FUSD" })];
                        default:
                            throw new Error("Unsupported fungible token");
                    }
                    return [2 /*return*/];
            }
        });
    });
}
exports.getOrderDetailsFromBlockchain = getOrderDetailsFromBlockchain;
