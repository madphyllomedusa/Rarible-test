"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var _1 = require(".");
describe("ElkLogger", function () {
    it("should correctly log data", function () { return (0, tslib_1.__awaiter)(void 0, void 0, void 0, function () {
        var handler, logger, _a, calls, result;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    handler = jest.fn();
                    logger = new _1.RemoteLogger(handler, {
                        dropBatchInterval: 100,
                    });
                    logger.info("test", {
                        name: "Ivan",
                        isCreator: true,
                    });
                    logger.error(new Error("My new error"), {
                        name: "Ivan",
                        isCreator: true,
                    });
                    return [4 /*yield*/, new Promise(function (resolve) {
                            setTimeout(function () {
                                resolve([handler.mock.calls.length, handler.mock.calls[0][0]]);
                            }, 200);
                        })];
                case 1:
                    _a = _b.sent(), calls = _a[0], result = _a[1];
                    expect(calls).toEqual(1);
                    expect(result).toStrictEqual([{
                            level: "INFO",
                            message: " \"test\", {\"name\":\"Ivan\",\"isCreator\":true}",
                        }, {
                            level: "ERROR",
                            message: " Error: My new error, {\"name\":\"Ivan\",\"isCreator\":true}",
                        }]);
                    return [2 /*return*/];
            }
        });
    }); });
    it("should correctly resolve contexts", function () { return (0, tslib_1.__awaiter)(void 0, void 0, void 0, function () {
        var handler, logger, _a, calls, result;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    handler = jest.fn();
                    logger = new _1.RemoteLogger(handler, {
                        dropBatchInterval: 100,
                        context: {
                            version: "1",
                        },
                        initialContext: new Promise(function (resolve) {
                            setTimeout(function () { return resolve({
                                date: "today",
                            }); }, 100);
                        }),
                    });
                    logger.info("test", {
                        name: "Ivan",
                        isCreator: true,
                    });
                    return [4 /*yield*/, new Promise(function (resolve) {
                            setTimeout(function () {
                                resolve([handler.mock.calls.length, handler.mock.calls[0][0]]);
                            }, 300);
                        })];
                case 1:
                    _a = _b.sent(), calls = _a[0], result = _a[1];
                    expect(calls).toEqual(1);
                    expect(result).toStrictEqual([{
                            level: "INFO",
                            message: " \"test\", {\"name\":\"Ivan\",\"isCreator\":true}",
                            date: "today",
                            version: "1",
                        }]);
                    return [2 /*return*/];
            }
        });
    }); });
});
