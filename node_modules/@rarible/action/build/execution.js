"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Execution = void 0;
var tslib_1 = require("tslib");
var Execution = /** @class */ (function () {
    function Execution(input, steps) {
        this.input = input;
        this.steps = steps;
        this.state = new Array(steps.length);
        this.promises = new Array(steps.length);
    }
    Object.defineProperty(Execution.prototype, "ids", {
        get: function () {
            return this.steps.map(function (s) { return s.id; });
        },
        enumerable: false,
        configurable: true
    });
    Execution.prototype.runAll = function () {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var i, last;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < this.ids.length)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.run(i)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        i++;
                        return [3 /*break*/, 1];
                    case 4:
                        last = this.state[this.ids.length - 1];
                        if (last.status === "resolved") {
                            return [2 /*return*/, last.value];
                        }
                        else {
                            throw new Error("Should never happen");
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    Execution.prototype.run = function (idx) {
        if (idx === 0) {
            return this.runInternal(idx, this.input);
        }
        if (idx >= this.steps.length) {
            throw new Error("Stage with index " + idx + " not found");
        }
        var prevState = this.state[idx - 1];
        if (prevState == null) {
            throw new Error("Stage " + (idx - 1) + " hasn't been run yet");
        }
        if (prevState.status !== "resolved") {
            throw new Error("Stage " + (idx - 1) + " status is: " + prevState.status);
        }
        return this.runInternal(idx, prevState.value);
    };
    Execution.prototype.runInternal = function (idx, input) {
        var _this = this;
        var state = this.state[idx];
        if (state != null && (state.status === "pending" || state.status === "resolved")) {
            return this.promises[idx];
        }
        else {
            this.state[idx] = { status: "pending" };
            var promise = this.steps[idx].run(input);
            this.promises[idx] = promise
                .then(function (r) {
                _this.state[idx] = { status: "resolved", value: r };
                return r;
            })
                .catch(function (err) {
                _this.state[idx] = { status: "rejected", error: err };
                return Promise.reject(err);
            });
            return this.promises[idx];
        }
    };
    Object.defineProperty(Execution.prototype, "result", {
        get: function () {
            return this.runAll();
        },
        enumerable: false,
        configurable: true
    });
    return Execution;
}());
exports.Execution = Execution;
