"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fill_order = exports.match_order_to_struct = void 0;
var tezos_common_1 = require("@rarible/tezos-common");
var utils_1 = require("./utils");
var invert_order_1 = require("./invert-order");
var get_make_fee_1 = require("./get-make-fee");
var add_fee_1 = require("./add-fee");
var approve_1 = require("./approve");
var sign_order_1 = require("./sign-order");
var permit_1 = require("../nft/permit");
var wrapper_1 = require("./wrapper");
var bignumber_js_1 = require("bignumber.js");
var node_fetch_1 = require("node-fetch");
function get_make_asset(provider, order, amount, edpk) {
    return __awaiter(this, void 0, void 0, function () {
        var inverted, make_fee;
        return __generator(this, function (_a) {
            inverted = (0, invert_order_1.invert_order)(order, amount, edpk);
            make_fee = (0, get_make_fee_1.get_make_fee)(provider.config.fees, inverted);
            return [2 /*return*/, (0, add_fee_1.add_fee)(provider, inverted.make, make_fee)];
        });
    });
}
function get_real_value(provider, order) {
    return __awaiter(this, void 0, void 0, function () {
        var fee, make;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    fee = (0, get_make_fee_1.get_make_fee)(provider.config.fees, order);
                    return [4 /*yield*/, (0, add_fee_1.add_fee)(provider, order.make, fee)];
                case 1:
                    make = _a.sent();
                    return [2 /*return*/, make.value];
            }
        });
    });
}
function match_order_to_struct(p, left, right) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, _b;
        var _c, _d, _e;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    _c = {
                        prim: "Pair"
                    };
                    return [4 /*yield*/, (0, sign_order_1.order_to_struct)(p, left)];
                case 1:
                    _a = [
                        _f.sent()
                    ];
                    _d = { prim: "Pair" };
                    _b = [(left.signature) ? (0, sign_order_1.some_struct)({ string: left.signature }) : (0, sign_order_1.none_struct)()];
                    _e = { prim: "Pair" };
                    return [4 /*yield*/, (0, sign_order_1.order_to_struct)(p, right)];
                case 2: return [2 /*return*/, (_c.args = _a.concat([
                        (_d.args = _b.concat([
                            (_e.args = [
                                _f.sent(),
                                (right.signature) ? (0, sign_order_1.some_struct)({ string: right.signature }) : (0, sign_order_1.none_struct)()
                            ], _e)
                        ]), _d)
                    ]),
                        _c)];
            }
        });
    });
}
exports.match_order_to_struct = match_order_to_struct;
function use_permit(provider, asset) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, mt_contract, nft_contract, decimals;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = asset.asset_type.asset_class;
                    switch (_a) {
                        case "XTZ": return [3 /*break*/, 1];
                        case "MT": return [3 /*break*/, 2];
                        case "NFT": return [3 /*break*/, 3];
                        case "FT": return [3 /*break*/, 4];
                    }
                    return [3 /*break*/, 7];
                case 1: return [2 /*return*/, undefined];
                case 2:
                    mt_contract = asset.asset_type.contract || provider.config.mt_public;
                    if (provider.config.permit_whitelist.includes(mt_contract)) {
                        return [2 /*return*/, { contract: mt_contract, token_id: asset.asset_type.token_id, amount: asset.value }];
                    }
                    else
                        return [2 /*return*/, undefined];
                    _b.label = 3;
                case 3:
                    nft_contract = asset.asset_type.contract || provider.config.nft_public;
                    if (provider.config.permit_whitelist.includes(nft_contract)) {
                        return [2 /*return*/, { contract: nft_contract, token_id: asset.asset_type.token_id, amount: asset.value }];
                    }
                    else
                        return [2 /*return*/, undefined];
                    _b.label = 4;
                case 4:
                    if (!(provider.config.permit_whitelist.includes(asset.asset_type.contract) && asset.asset_type.token_id != undefined)) return [3 /*break*/, 6];
                    return [4 /*yield*/, (0, sign_order_1.get_decimals)(provider, asset.asset_type.contract, asset.asset_type.token_id)];
                case 5:
                    decimals = _b.sent();
                    return [2 /*return*/, { contract: asset.asset_type.contract, token_id: asset.asset_type.token_id,
                            amount: asset.value.times((new bignumber_js_1.default(10).pow(decimals))) }];
                case 6: return [2 /*return*/, undefined];
                case 7: return [2 /*return*/];
            }
        });
    });
}
function fill_order_unwrap_amount(provider, right, asset_type) {
    return __awaiter(this, void 0, void 0, function () {
        var payout_part, fees, value, decimals, decimal_factor;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    payout_part = right.data.payouts.find(function (p) { return p.account == right.taker; });
                    if (!(payout_part == undefined)) return [3 /*break*/, 1];
                    return [2 /*return*/, new bignumber_js_1.default(0)];
                case 1:
                    fees = (0, get_make_fee_1.get_make_fee)(provider.config.fees, right);
                    return [4 /*yield*/, (0, add_fee_1.add_fee)(provider, right.take, fees, true)];
                case 2:
                    value = (_a.sent()).value;
                    value = value.times(payout_part.value).div(10000);
                    return [4 /*yield*/, (0, sign_order_1.get_decimals)(provider, asset_type.contract, asset_type.token_id)];
                case 3:
                    decimals = _a.sent();
                    decimal_factor = new bignumber_js_1.default(10).pow(decimals);
                    return [2 /*return*/, value.times(decimal_factor).integerValue().div(decimal_factor)];
            }
        });
    });
}
function fill_order(provider, left, request, unwrap, unwrap_amount) {
    if (unwrap === void 0) { unwrap = false; }
    return __awaiter(this, void 0, void 0, function () {
        var pk, _a, make, up, right, arg_approve, _b, _c, _d, args, amount, _e, _f, parameter, _g, _h, _j, _k, _l, right_salt, signature, mp, r_add, _m, _o, r_match, _p, _q, json, hash;
        var _this = this;
        return __generator(this, function (_r) {
            switch (_r.label) {
                case 0:
                    if (!(request.edpk)) return [3 /*break*/, 1];
                    _a = request.edpk;
                    return [3 /*break*/, 3];
                case 1: return [4 /*yield*/, (0, tezos_common_1.get_public_key)(provider)];
                case 2:
                    _a = _r.sent();
                    _r.label = 3;
                case 3:
                    pk = _a;
                    if (!pk)
                        throw new Error("cannot get public key");
                    return [4 /*yield*/, get_make_asset(provider, left, request.amount, pk)];
                case 4:
                    make = _r.sent();
                    return [4 /*yield*/, use_permit(provider, make)];
                case 5:
                    up = _r.sent();
                    right = __assign(__assign({}, (0, invert_order_1.invert_order)(left, request.amount, pk)), { data: __assign(__assign({}, left.data), { payouts: request.payouts || [], origin_fees: request.origin_fees || [] }) });
                    return [4 /*yield*/, (0, utils_1.fill_offchain_royalties)(provider, right)];
                case 6:
                    right = _r.sent();
                    if (!(up == undefined)) return [3 /*break*/, 22];
                    if (!(make.asset_type.asset_class != "XTZ")) return [3 /*break*/, 9];
                    _c = approve_1.approve_arg;
                    _d = [provider];
                    return [4 /*yield*/, (0, tezos_common_1.get_address)(provider)];
                case 7: return [4 /*yield*/, _c.apply(void 0, _d.concat([_r.sent(), make, request.use_all, request.infinite]))];
                case 8:
                    _b = _r.sent();
                    return [3 /*break*/, 10];
                case 9:
                    _b = undefined;
                    _r.label = 10;
                case 10:
                    arg_approve = _b;
                    args = (arg_approve) ? [arg_approve] : [];
                    if (!(left.make.asset_type.asset_class === "XTZ" && left.salt == '0')) return [3 /*break*/, 12];
                    return [4 /*yield*/, get_real_value(provider, left)];
                case 11:
                    _e = _r.sent();
                    return [3 /*break*/, 16];
                case 12:
                    if (!(right.make.asset_type.asset_class === "XTZ" && right.salt == '0')) return [3 /*break*/, 14];
                    return [4 /*yield*/, get_real_value(provider, right)];
                case 13:
                    _f = _r.sent();
                    return [3 /*break*/, 15];
                case 14:
                    _f = undefined;
                    _r.label = 15;
                case 15:
                    _e = _f;
                    _r.label = 16;
                case 16:
                    amount = _e;
                    return [4 /*yield*/, match_order_to_struct(provider, left, right)];
                case 17:
                    parameter = _r.sent();
                    args = args.concat({
                        destination: provider.config.exchange, entrypoint: "match_orders",
                        parameter: parameter,
                        amount: amount
                    });
                    if (!(unwrap && right.take.asset_type.asset_class == "FT" && right.take.asset_type.contract == provider.config.wrapper && right.take.asset_type.token_id != undefined && right.take.asset_type.token_id.isZero())) return [3 /*break*/, 21];
                    _h = (_g = args).concat;
                    _j = wrapper_1.unwrap_arg;
                    _k = [provider];
                    _l = unwrap_amount;
                    if (_l) return [3 /*break*/, 19];
                    return [4 /*yield*/, fill_order_unwrap_amount(provider, right, right.take.asset_type)];
                case 18:
                    _l = (_r.sent());
                    _r.label = 19;
                case 19: return [4 /*yield*/, _j.apply(void 0, _k.concat([_l]))];
                case 20:
                    args = _h.apply(_g, [_r.sent()]);
                    _r.label = 21;
                case 21: return [2 /*return*/, (0, tezos_common_1.send_batch)(provider, args)];
                case 22:
                    right_salt = (0, utils_1.salt)();
                    right = __assign(__assign({}, right), { salt: right_salt });
                    return [4 /*yield*/, (0, sign_order_1.sign_order)(provider, right)];
                case 23:
                    signature = _r.sent();
                    right = __assign(__assign({}, right), { signature: signature });
                    return [4 /*yield*/, (0, permit_1.make_permit)(provider, up.contract, [{
                                destination: left.maker, token_id: up.token_id, amount: up.amount
                            }])];
                case 24:
                    mp = _r.sent();
                    return [4 /*yield*/, (0, node_fetch_1.default)(provider.config.api_permit + '/permit/add', {
                            method: 'POST', headers: [['content-type', 'application/json']],
                            body: JSON.stringify(mp.permit)
                        })];
                case 25:
                    r_add = _r.sent();
                    if (!!r_add.ok) return [3 /*break*/, 27];
                    _m = Error.bind;
                    _o = r_add.statusText + ' ';
                    return [4 /*yield*/, r_add.text()];
                case 26: throw new (_m.apply(Error, [void 0, _o + (_r.sent())]))();
                case 27: return [4 /*yield*/, (0, node_fetch_1.default)(provider.config.api_permit + '/permit/match_orders', {
                        method: 'POST', headers: [['content-type', 'application/json']],
                        body: JSON.stringify({
                            left: (0, utils_1.order_to_json)(left), right: (0, utils_1.order_to_json)(right)
                        })
                    })];
                case 28:
                    r_match = _r.sent();
                    if (!!r_match.ok) return [3 /*break*/, 30];
                    _p = Error.bind;
                    _q = r_match.statusText + ' ';
                    return [4 /*yield*/, r_match.text()];
                case 29: throw new (_p.apply(Error, [void 0, _q + (_r.sent())]))();
                case 30: return [4 /*yield*/, r_match.json()];
                case 31:
                    json = _r.sent();
                    hash = JSON.parse(json).hash;
                    return [2 /*return*/, { hash: hash, confirmation: (function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2 /*return*/, undefined];
                            }); }); }) }];
            }
        });
    });
}
exports.fill_order = fill_order;
