import type { Address, Asset, Binary, Erc1155AssetType, Erc721AssetType } from "@rarible/ethereum-api-client";
import type { Ethereum, EthereumTransaction } from "@rarible/ethereum-provider";
import type { Maybe } from "@rarible/types/build/maybe";
import type { BigNumberValue } from "@rarible/utils/build/bn";
import type { SendFunction } from "../../common/send-transaction";
import type { EthereumConfig } from "../../config/type";
import type { SimpleOpenSeaV1Order, SimpleOrder } from "../types";
import type { RaribleEthereumApis } from "../../common/apis";
import type { IRaribleEthereumSdkConfig } from "../../types";
import type { OpenSeaOrderDTO } from "./open-sea-types";
import type { OpenSeaV1OrderFillRequest, OrderFillSendData, OrderHandler } from "./types";
export declare type EncodedOrderCallData = {
    callData: Binary;
    replacementPattern: Binary;
    target: Address;
};
export declare class OpenSeaOrderHandler implements OrderHandler<OpenSeaV1OrderFillRequest> {
    private readonly ethereum;
    private readonly send;
    private readonly config;
    private readonly apis;
    private readonly getBaseOrderFeeConfig;
    private readonly sdkConfig?;
    constructor(ethereum: Maybe<Ethereum>, send: SendFunction, config: EthereumConfig, apis: RaribleEthereumApis, getBaseOrderFeeConfig: (type: SimpleOrder["type"]) => Promise<number>, sdkConfig?: IRaribleEthereumSdkConfig | undefined);
    getOrderMetadata(): import("@rarible/ethereum-api-client").Word;
    invert({ order }: OpenSeaV1OrderFillRequest, maker: Address): Promise<SimpleOpenSeaV1Order>;
    encodeOrder(order: SimpleOpenSeaV1Order): Promise<EncodedOrderCallData>;
    getErc721EncodedData(assetType: Erc721AssetType, maker: Address, isSellSide: boolean, validatorAddress: Address | undefined, initialCalldata: Binary): Promise<EncodedOrderCallData>;
    getErc1155EncodedData(assetType: Erc1155AssetType, value: BigNumberValue, maker: Address, isSellSide: boolean, validatorAddress: Address | undefined): Promise<EncodedOrderCallData>;
    getBaseOrderFee(): Promise<number>;
    getOrderFee(order: SimpleOpenSeaV1Order): number;
    approve(order: SimpleOpenSeaV1Order, infinite: boolean): Promise<void>;
    getTransactionData(initial: SimpleOpenSeaV1Order, inverted: SimpleOpenSeaV1Order): Promise<OrderFillSendData>;
    sendTransaction(initial: SimpleOpenSeaV1Order, inverted: SimpleOpenSeaV1Order): Promise<EthereumTransaction>;
    approveSingle(maker: Address, asset: Asset, infinite?: undefined | boolean): Promise<EthereumTransaction | undefined>;
    private getRegisteredProxy;
}
export declare function getAtomicMatchArgAddresses(dto: OpenSeaOrderDTO): Address[];
export declare function getAtomicMatchArgUints(dto: OpenSeaOrderDTO): import("@rarible/ethereum-api-client").BigNumber[];
export declare function getAtomicMatchArgCommonData(dto: OpenSeaOrderDTO): (import("./open-sea-types").OrderOpenSeaV1DataV1FeeMethod | import("./open-sea-types").OrderOpenSeaV1DataV1Side | import("./open-sea-types").OrderOpenSeaV1DataV1SaleKind | import("./open-sea-types").OrderOpenSeaV1DataV1HowToCall)[];
