"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CryptoPunksOrderHandler = void 0;
var tslib_1 = require("tslib");
var get_asset_with_fee_1 = require("../get-asset-with-fee");
var approve_1 = require("../approve");
var wait_tx_1 = require("../../common/wait-tx");
var cryptoPunks_1 = require("../../nft/contracts/cryptoPunks");
var invert_order_1 = require("./invert-order");
var CryptoPunksOrderHandler = /** @class */ (function () {
    function CryptoPunksOrderHandler(ethereum, send, config, getBaseOrderFeeConfig) {
        this.ethereum = ethereum;
        this.send = send;
        this.config = config;
        this.getBaseOrderFeeConfig = getBaseOrderFeeConfig;
    }
    CryptoPunksOrderHandler.prototype.invert = function (request, maker) {
        var inverted = (0, invert_order_1.invertOrder)(request.order, request.amount, maker);
        inverted.data = {
            dataType: "CRYPTO_PUNKS_DATA",
        };
        return inverted;
    };
    CryptoPunksOrderHandler.prototype.approve = function (order, infinite) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var withFee;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.ethereum) {
                            throw new Error("Wallet undefined");
                        }
                        withFee = this.getMakeAssetWithFee(order);
                        return [4 /*yield*/, (0, wait_tx_1.waitTx)((0, approve_1.approve)(this.ethereum, this.send, this.config.transferProxies, order.maker, withFee, infinite))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    CryptoPunksOrderHandler.prototype.getTransactionData = function (initial, inverted) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                return [2 /*return*/, {
                        functionCall: this.getPunkOrderCallMethod(initial),
                        options: this.getMatchV2Options(initial, inverted),
                    }];
            });
        });
    };
    CryptoPunksOrderHandler.prototype.sendTransaction = function (initial, inverted) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, functionCall, options;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getTransactionData(initial, inverted)];
                    case 1:
                        _a = _b.sent(), functionCall = _a.functionCall, options = _a.options;
                        return [2 /*return*/, this.send(functionCall, options)];
                }
            });
        });
    };
    CryptoPunksOrderHandler.prototype.getPunkOrderCallMethod = function (initial) {
        if (!this.ethereum) {
            throw new Error("Wallet undefined");
        }
        if (initial.make.assetType.assetClass === "CRYPTO_PUNKS") {
            // Call "buyPunk" if makeAsset=cryptoPunk
            var contract = (0, cryptoPunks_1.createCryptoPunksMarketContract)(this.ethereum, initial.make.assetType.contract);
            return contract.functionCall("buyPunk", initial.make.assetType.tokenId);
        }
        else if (initial.take.assetType.assetClass === "CRYPTO_PUNKS") {
            // Call "acceptBid" if takeAsset=cryptoPunk
            var contract = (0, cryptoPunks_1.createCryptoPunksMarketContract)(this.ethereum, initial.take.assetType.contract);
            return contract.functionCall("acceptBidForPunk", initial.take.assetType.tokenId, initial.make.value);
        }
        else {
            throw new Error("Unsupported punk asset type");
        }
    };
    CryptoPunksOrderHandler.prototype.getMatchV2Options = function (left, right) {
        if (right.make.assetType.assetClass === "ETH") {
            var asset = this.getMakeAssetWithFee(right);
            return { value: asset.value };
        }
        else {
            return {};
        }
    };
    CryptoPunksOrderHandler.prototype.getMakeAssetWithFee = function (order) {
        return (0, get_asset_with_fee_1.getAssetWithFee)(order.make, this.getOrderFee());
    };
    CryptoPunksOrderHandler.prototype.getOrderFee = function () {
        return 0;
    };
    CryptoPunksOrderHandler.prototype.getBaseOrderFee = function () {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                return [2 /*return*/, this.getBaseOrderFeeConfig("CRYPTO_PUNK")];
            });
        });
    };
    return CryptoPunksOrderHandler;
}());
exports.CryptoPunksOrderHandler = CryptoPunksOrderHandler;
