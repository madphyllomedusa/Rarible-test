"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toStructLegacyOrderKey = exports.toStructLegacyOrder = exports.RaribleV1OrderHandler = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var utils_1 = require("@rarible/utils");
var approve_1 = require("../approve");
var get_asset_with_fee_1 = require("../get-asset-with-fee");
var exchange_v1_1 = require("../contracts/exchange-v1");
var to_legacy_asset_type_1 = require("../to-legacy-asset-type");
var to_vrs_1 = require("../../common/to-vrs");
var wait_tx_1 = require("../../common/wait-tx");
var invert_order_1 = require("./invert-order");
var RaribleV1OrderHandler = /** @class */ (function () {
    function RaribleV1OrderHandler(ethereum, orderApi, send, config, getBaseOrderFeeConfig) {
        this.ethereum = ethereum;
        this.orderApi = orderApi;
        this.send = send;
        this.config = config;
        this.getBaseOrderFeeConfig = getBaseOrderFeeConfig;
    }
    RaribleV1OrderHandler.prototype.invert = function (request, maker) {
        var inverted = (0, invert_order_1.invertOrder)(request.order, request.amount, maker);
        inverted.data = {
            dataType: "LEGACY",
            fee: request.originFee,
        };
        return inverted;
    };
    RaribleV1OrderHandler.prototype.approve = function (order, infinite) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var withFee;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.ethereum) {
                            throw new Error("Wallet undefined");
                        }
                        withFee = (0, get_asset_with_fee_1.getAssetWithFee)(order.make, this.getOrderFee(order));
                        return [4 /*yield*/, (0, wait_tx_1.waitTx)((0, approve_1.approve)(this.ethereum, this.send, this.config.transferProxies, order.maker, withFee, infinite))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    RaribleV1OrderHandler.prototype.getBaseOrderFee = function () {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                return [2 /*return*/, this.getBaseOrderFeeConfig("RARIBLE_V1")];
            });
        });
    };
    RaribleV1OrderHandler.prototype.getOrderFee = function (order) {
        return order.data.fee;
    };
    RaribleV1OrderHandler.prototype.getTransactionData = function (initial, inverted, request) {
        var _a;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var buyerFeeSig, exchangeContract, functionCall;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.ethereum) {
                            throw new Error("Wallet undefined");
                        }
                        return [4 /*yield*/, this.orderApi.buyerFeeSignature({ fee: inverted.data.fee, orderForm: fromSimpleOrderToOrderForm(initial) })];
                    case 1:
                        buyerFeeSig = _b.sent();
                        exchangeContract = (0, exchange_v1_1.createExchangeV1Contract)(this.ethereum, this.config.exchange.v1);
                        functionCall = exchangeContract.functionCall("exchange", toStructLegacyOrder(initial), (0, to_vrs_1.toVrs)(initial.signature), inverted.data.fee, (0, to_vrs_1.toVrs)(buyerFeeSig), inverted.take.value, (_a = request.payout) !== null && _a !== void 0 ? _a : types_1.ZERO_ADDRESS);
                        return [2 /*return*/, {
                                functionCall: functionCall,
                                options: getMatchV1Options(inverted),
                            }];
                }
            });
        });
    };
    RaribleV1OrderHandler.prototype.sendTransaction = function (initial, inverted, request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, functionCall, options;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getTransactionData(initial, inverted, request)];
                    case 1:
                        _a = _b.sent(), functionCall = _a.functionCall, options = _a.options;
                        return [2 /*return*/, this.send(functionCall, options)];
                }
            });
        });
    };
    return RaribleV1OrderHandler;
}());
exports.RaribleV1OrderHandler = RaribleV1OrderHandler;
function getMatchV1Options(order) {
    if (order.make.assetType.assetClass === "ETH") {
        var makeAsset = (0, get_asset_with_fee_1.getAssetWithFee)(order.make, order.data.fee);
        return { value: makeAsset.value };
    }
    else {
        return {};
    }
}
function toStructLegacyOrder(order) {
    if (order.type !== "RARIBLE_V1") {
        throw new Error("Not supported type: ".concat(order.type));
    }
    var data = order.data;
    if (data.dataType !== "LEGACY") {
        throw new Error("Not supported data type: ".concat(data.dataType));
    }
    return {
        key: toStructLegacyOrderKey(order),
        selling: order.make.value,
        buying: order.take.value,
        sellerFee: data.fee,
    };
}
exports.toStructLegacyOrder = toStructLegacyOrder;
function toStructLegacyOrderKey(order) {
    return {
        owner: order.maker,
        salt: order.salt,
        sellAsset: (0, to_legacy_asset_type_1.toLegacyAssetType)(order.make.assetType),
        buyAsset: (0, to_legacy_asset_type_1.toLegacyAssetType)(order.take.assetType),
    };
}
exports.toStructLegacyOrderKey = toStructLegacyOrderKey;
function fromSimpleOrderToOrderForm(order) {
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, order), { salt: (0, types_1.toBigNumber)((0, utils_1.toBn)(order.salt).toString()), signature: order.signature || (0, types_1.toBinary)("0x") });
}
