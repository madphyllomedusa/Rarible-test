"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderFiller = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var action_1 = require("@rarible/action");
var check_asset_type_1 = require("../check-asset-type");
var check_lazy_asset_type_1 = require("../check-lazy-asset-type");
var check_chain_id_1 = require("../check-chain-id");
var rarible_v1_1 = require("./rarible-v1");
var rarible_v2_1 = require("./rarible-v2");
var open_sea_1 = require("./open-sea");
var crypto_punks_1 = require("./crypto-punks");
var OrderFiller = /** @class */ (function () {
    function OrderFiller(ethereum, send, config, apis, getBaseOrderFee, sdkConfig) {
        this.ethereum = ethereum;
        this.send = send;
        this.config = config;
        this.apis = apis;
        this.getBaseOrderFee = getBaseOrderFee;
        this.sdkConfig = sdkConfig;
        /**
         * @deprecated Use {@link buy} or {@link acceptBid} instead
         */
        this.fill = this.getFillAction();
        /**
         * Buy order
         */
        this.buy = this.getFillAction();
        /**
         * Accept bid order
         */
        this.acceptBid = this.getFillAction();
        this.getBaseOrderFillFee = this.getBaseOrderFillFee.bind(this);
        this.getTransactionData = this.getTransactionData.bind(this);
        this.getBuyTx = this.getBuyTx.bind(this);
        this.v1Handler = new rarible_v1_1.RaribleV1OrderHandler(ethereum, apis.order, send, config, getBaseOrderFee);
        this.v2Handler = new rarible_v2_1.RaribleV2OrderHandler(ethereum, send, config, getBaseOrderFee);
        this.openSeaHandler = new open_sea_1.OpenSeaOrderHandler(ethereum, send, config, apis, getBaseOrderFee, sdkConfig);
        this.punkHandler = new crypto_punks_1.CryptoPunksOrderHandler(ethereum, send, config, getBaseOrderFee);
        this.checkAssetType = check_asset_type_1.checkAssetType.bind(this, apis.nftCollection);
        this.checkLazyAssetType = check_lazy_asset_type_1.checkLazyAssetType.bind(this, apis.nftItem);
    }
    OrderFiller.prototype.getFillAction = function () {
        var _this = this;
        return action_1.Action
            .create({
            id: "approve",
            run: function (request) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                var from, _a, inverted, _b, _c;
                return (0, tslib_1.__generator)(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            if (!this.ethereum) {
                                throw new Error("Wallet undefined");
                            }
                            _a = types_1.toAddress;
                            return [4 /*yield*/, this.ethereum.getFrom()];
                        case 1:
                            from = _a.apply(void 0, [_d.sent()]);
                            return [4 /*yield*/, this.invertOrder(request, from)];
                        case 2:
                            inverted = _d.sent();
                            if (!(request.assetType && inverted.make.assetType.assetClass === "COLLECTION")) return [3 /*break*/, 5];
                            _b = inverted.make;
                            return [4 /*yield*/, this.checkAssetType(request.assetType)];
                        case 3:
                            _b.assetType = _d.sent();
                            _c = inverted.make;
                            return [4 /*yield*/, this.checkLazyAssetType(inverted.make.assetType)];
                        case 4:
                            _c.assetType = _d.sent();
                            _d.label = 5;
                        case 5: return [4 /*yield*/, this.approveOrder(inverted, Boolean(request.infinite))];
                        case 6:
                            _d.sent();
                            return [2 /*return*/, { request: request, inverted: inverted }];
                    }
                });
            }); },
        })
            .thenStep({
            id: "send-tx",
            run: function (_a) {
                var inverted = _a.inverted, request = _a.request;
                return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                    return (0, tslib_1.__generator)(this, function (_b) {
                        return [2 /*return*/, this.sendTransaction(request, inverted)];
                    });
                });
            },
        })
            .before(function (input) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, check_chain_id_1.checkChainId)(this.ethereum, this.config)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, input];
                }
            });
        }); });
    };
    OrderFiller.prototype.getBuyTx = function (_a) {
        var _b;
        var request = _a.request, from = _a.from;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var inverted, _c, _d, functionCall, options, callInfo, value;
            return (0, tslib_1.__generator)(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, this.invertOrder(request, from)];
                    case 1:
                        inverted = _e.sent();
                        if (!(request.assetType && inverted.make.assetType.assetClass === "COLLECTION")) return [3 /*break*/, 3];
                        _c = inverted.make;
                        return [4 /*yield*/, this.checkAssetType(request.assetType)];
                    case 2:
                        _c.assetType = _e.sent();
                        _e.label = 3;
                    case 3: return [4 /*yield*/, this.getTransactionRequestData(request, inverted)];
                    case 4:
                        _d = _e.sent(), functionCall = _d.functionCall, options = _d.options;
                        return [4 /*yield*/, functionCall.getCallInfo()];
                    case 5:
                        callInfo = _e.sent();
                        value = ((_b = options.value) === null || _b === void 0 ? void 0 : _b.toString()) || "0";
                        return [2 /*return*/, {
                                from: from,
                                value: value,
                                data: functionCall.data,
                                to: callInfo.contract,
                            }];
                }
            });
        });
    };
    OrderFiller.prototype.invertOrder = function (request, from) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (request.order.type) {
                    case "RARIBLE_V1":
                        return [2 /*return*/, this.v1Handler.invert(request, from)];
                    case "RARIBLE_V2":
                        return [2 /*return*/, this.v2Handler.invert(request, from)];
                    case "OPEN_SEA_V1":
                        return [2 /*return*/, this.openSeaHandler.invert(request, from)];
                    case "CRYPTO_PUNK":
                        return [2 /*return*/, this.punkHandler.invert(request, from)];
                    default:
                        throw new Error("Unsupported order: ".concat(JSON.stringify(request)));
                }
                return [2 /*return*/];
            });
        });
    };
    OrderFiller.prototype.approveOrder = function (inverted, isInfinite) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (inverted.type) {
                    case "RARIBLE_V1":
                        return [2 /*return*/, this.v1Handler.approve(inverted, isInfinite)];
                    case "RARIBLE_V2":
                        return [2 /*return*/, this.v2Handler.approve(inverted, isInfinite)];
                    case "OPEN_SEA_V1":
                        return [2 /*return*/, this.openSeaHandler.approve(inverted, isInfinite)];
                    case "CRYPTO_PUNK":
                        return [2 /*return*/, this.punkHandler.approve(inverted, isInfinite)];
                    default:
                        throw new Error("Unsupported order: ".concat(JSON.stringify(inverted)));
                }
                return [2 /*return*/];
            });
        });
    };
    OrderFiller.prototype.sendTransaction = function (request, inverted) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (inverted.type) {
                    case "RARIBLE_V1":
                        return [2 /*return*/, this.v1Handler.sendTransaction(request.order, inverted, request)];
                    case "RARIBLE_V2":
                        return [2 /*return*/, this.v2Handler.sendTransaction(request.order, inverted)];
                    case "OPEN_SEA_V1":
                        return [2 /*return*/, this.openSeaHandler.sendTransaction(request.order, inverted)];
                    case "CRYPTO_PUNK":
                        return [2 /*return*/, this.punkHandler.sendTransaction(request.order, inverted)];
                    default:
                        throw new Error("Unsupported order: ".concat(JSON.stringify(inverted)));
                }
                return [2 /*return*/];
            });
        });
    };
    OrderFiller.prototype.getTransactionRequestData = function (request, inverted) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (request.order.type) {
                    case "RARIBLE_V1":
                        return [2 /*return*/, this.v1Handler.getTransactionData(request.order, inverted, request)];
                    case "RARIBLE_V2":
                        return [2 /*return*/, this.v2Handler.getTransactionData(request.order, inverted)];
                    case "OPEN_SEA_V1":
                        return [2 /*return*/, this.openSeaHandler.getTransactionData(request.order, inverted)];
                    case "CRYPTO_PUNK":
                        return [2 /*return*/, this.punkHandler.getTransactionData(request.order, inverted)];
                    default:
                        throw new Error("Unsupported request: ".concat(JSON.stringify(request)));
                }
                return [2 /*return*/];
            });
        });
    };
    OrderFiller.prototype.getTransactionData = function (request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var from, _a, inverted, _b, _c, functionCall, options;
            return (0, tslib_1.__generator)(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (!this.ethereum) {
                            throw new Error("Wallet undefined");
                        }
                        return [4 /*yield*/, (0, check_chain_id_1.checkChainId)(this.ethereum, this.config)];
                    case 1:
                        _d.sent();
                        _a = types_1.toAddress;
                        return [4 /*yield*/, this.ethereum.getFrom()];
                    case 2:
                        from = _a.apply(void 0, [_d.sent()]);
                        return [4 /*yield*/, this.invertOrder(request, from)];
                    case 3:
                        inverted = _d.sent();
                        if (!(request.assetType && inverted.make.assetType.assetClass === "COLLECTION")) return [3 /*break*/, 5];
                        _b = inverted.make;
                        return [4 /*yield*/, this.checkAssetType(request.assetType)];
                    case 4:
                        _b.assetType = _d.sent();
                        _d.label = 5;
                    case 5: return [4 /*yield*/, this.getTransactionRequestData(request, inverted)];
                    case 6:
                        _c = _d.sent(), functionCall = _c.functionCall, options = _c.options;
                        return [2 /*return*/, {
                                data: functionCall.data,
                                options: options,
                            }];
                }
            });
        });
    };
    OrderFiller.prototype.getOrderFee = function (order) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (order.type) {
                    case "RARIBLE_V1":
                        return [2 /*return*/, this.v1Handler.getOrderFee(order)];
                    case "RARIBLE_V2":
                        return [2 /*return*/, this.v2Handler.getOrderFee(order)];
                    case "OPEN_SEA_V1":
                        return [2 /*return*/, this.openSeaHandler.getOrderFee(order)];
                    case "CRYPTO_PUNK":
                        return [2 /*return*/, this.punkHandler.getOrderFee()];
                    default:
                        throw new Error("Unsupported order: ".concat(JSON.stringify(order)));
                }
                return [2 /*return*/];
            });
        });
    };
    OrderFiller.prototype.getBaseOrderFillFee = function (order) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (order.type) {
                    case "RARIBLE_V1":
                        return [2 /*return*/, this.v1Handler.getBaseOrderFee()];
                    case "RARIBLE_V2":
                        return [2 /*return*/, this.v2Handler.getBaseOrderFee()];
                    case "OPEN_SEA_V1":
                        return [2 /*return*/, this.openSeaHandler.getBaseOrderFee()];
                    case "CRYPTO_PUNK":
                        return [2 /*return*/, this.punkHandler.getBaseOrderFee()];
                    default:
                        throw new Error("Unsupported order: ".concat(JSON.stringify(order)));
                }
                return [2 /*return*/];
            });
        });
    };
    return OrderFiller;
}());
exports.OrderFiller = OrderFiller;
