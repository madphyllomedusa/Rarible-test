"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAtomicMatchArgCommonData = exports.getAtomicMatchArgUints = exports.getAtomicMatchArgAddresses = exports.OpenSeaOrderHandler = void 0;
var tslib_1 = require("tslib");
var ethereum_api_client_1 = require("@rarible/ethereum-api-client");
var types_1 = require("@rarible/types");
var exponential_backoff_1 = require("exponential-backoff");
var utils_1 = require("@rarible/utils");
var proxy_registry_opensea_1 = require("../contracts/proxy-registry-opensea");
var approve_erc20_1 = require("../approve-erc20");
var approve_erc721_1 = require("../approve-erc721");
var approve_erc1155_1 = require("../approve-erc1155");
var get_asset_with_fee_1 = require("../get-asset-with-fee");
var exchange_opensea_v1_1 = require("../contracts/exchange-opensea-v1");
var to_vrs_1 = require("../../common/to-vrs");
var wait_tx_1 = require("../../common/wait-tx");
var get_required_wallet_1 = require("../../common/get-required-wallet");
var erc721_1 = require("../../nft/contracts/erc721");
var domain_1 = require("../../nft/contracts/domain");
var merkle_validator_1 = require("../contracts/merkle-validator");
var erc1155_1 = require("../contracts/erc1155");
var get_blockchain_from_chain_id_1 = require("../../common/get-blockchain-from-chain-id");
var id_1 = require("../../common/id");
var open_sea_converter_1 = require("./open-sea-converter");
var OpenSeaOrderHandler = /** @class */ (function () {
    function OpenSeaOrderHandler(ethereum, send, config, apis, getBaseOrderFeeConfig, sdkConfig) {
        this.ethereum = ethereum;
        this.send = send;
        this.config = config;
        this.apis = apis;
        this.getBaseOrderFeeConfig = getBaseOrderFeeConfig;
        this.sdkConfig = sdkConfig;
    }
    OpenSeaOrderHandler.prototype.getOrderMetadata = function () {
        var blockchain = (0, get_blockchain_from_chain_id_1.getBlockchainFromChainId)(this.config.chainId);
        var ethereumNetworkConfig = getEthereumNetworkConfig(blockchain, this.sdkConfig);
        if (ethereumNetworkConfig && ethereumNetworkConfig.openseaOrdersMetadata) {
            return (0, types_1.toWord)(ethereumNetworkConfig.openseaOrdersMetadata);
        }
        return this.config.openSea.metadata || (0, id_1.id32)("RARIBLE");
    };
    OpenSeaOrderHandler.prototype.invert = function (_a, maker) {
        var order = _a.order;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var data, invertedOrder, _b, _c;
            return (0, tslib_1.__generator)(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        if (order.data.side === "BUY") {
                            throw new Error("Bid opensea orders is not supported yet");
                        }
                        if (order.data.feeRecipient === types_1.ZERO_ADDRESS) {
                            throw new Error("feeRecipient should be specified");
                        }
                        data = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, order.data), { feeRecipient: types_1.ZERO_ADDRESS, side: ethereum_api_client_1.OrderOpenSeaV1DataV1Side.BUY });
                        invertedOrder = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, order), { make: (0, tslib_1.__assign)({}, order.take), take: (0, tslib_1.__assign)({}, order.make), maker: maker, taker: order.maker, signature: undefined, data: data });
                        _b = invertedOrder;
                        _c = [(0, tslib_1.__assign)({}, invertedOrder.data)];
                        return [4 /*yield*/, this.encodeOrder(invertedOrder)];
                    case 1:
                        _b.data = tslib_1.__assign.apply(void 0, _c.concat([(_d.sent())]));
                        return [2 /*return*/, invertedOrder];
                }
            });
        });
    };
    OpenSeaOrderHandler.prototype.encodeOrder = function (order) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var makeAssetType, takeAssetType, validatorAddress;
            return (0, tslib_1.__generator)(this, function (_a) {
                makeAssetType = order.make.assetType;
                takeAssetType = order.take.assetType;
                validatorAddress = order.data.target && order.data.target === this.config.openSea.merkleValidator
                    ? order.data.target
                    : undefined;
                if (makeAssetType.assetClass === "ERC721") {
                    return [2 /*return*/, this.getErc721EncodedData(makeAssetType, order.maker, true, validatorAddress, order.data.callData)];
                }
                else if (makeAssetType.assetClass === "ERC1155") {
                    return [2 /*return*/, this.getErc1155EncodedData(makeAssetType, order.make.value, order.maker, true, validatorAddress)];
                }
                else if (takeAssetType.assetClass === "ERC721") {
                    return [2 /*return*/, this.getErc721EncodedData(takeAssetType, order.maker, false, validatorAddress, order.data.callData)];
                }
                else if (takeAssetType.assetClass === "ERC1155") {
                    return [2 /*return*/, this.getErc1155EncodedData(takeAssetType, order.take.value, order.maker, false, validatorAddress)];
                }
                else {
                    throw new Error("should never happen");
                }
                return [2 /*return*/];
            });
        });
    };
    OpenSeaOrderHandler.prototype.getErc721EncodedData = function (assetType, maker, isSellSide, validatorAddress, initialCalldata) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var ethereum, startArgs, c, isSafeV3Method, callMethod, methodArgs, callData, transferArgs, isSafeV3Method, c, c;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        ethereum = (0, get_required_wallet_1.getRequiredWallet)(this.ethereum);
                        startArgs = [maker, types_1.ZERO_ADDRESS];
                        if (!isSellSide) {
                            startArgs = [types_1.ZERO_ADDRESS, maker];
                        }
                        if (!validatorAddress) return [3 /*break*/, 1];
                        c = (0, merkle_validator_1.createMerkleValidatorContract)(ethereum, validatorAddress);
                        isSafeV3Method = initialCalldata.startsWith(MATCH_ERC721_SAFE_TRANSFER_SIGNATURE);
                        callMethod = isSafeV3Method ? "matchERC721WithSafeTransferUsingCriteria" : "matchERC721UsingCriteria";
                        methodArgs = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], startArgs, true), [assetType.contract, assetType.tokenId, "0x", []], false);
                        return [2 /*return*/, {
                                replacementPattern: isSellSide ? open_sea_converter_1.ERC721_VALIDATOR_MAKE_REPLACEMENT : open_sea_converter_1.ERC721_VALIDATOR_TAKE_REPLACEMENT,
                                callData: (0, types_1.toBinary)(c.functionCall.apply(c, (0, tslib_1.__spreadArray)([callMethod], methodArgs, false)).data),
                                target: validatorAddress,
                            }];
                    case 1:
                        callData = void 0;
                        transferArgs = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], startArgs, true), [assetType.tokenId], false);
                        isSafeV3Method = initialCalldata.startsWith(SAFE_TRANSFER_SIGNATURE);
                        if (!isSafeV3Method) return [3 /*break*/, 3];
                        return [4 /*yield*/, (0, erc721_1.getErc721Contract)(ethereum, domain_1.ERC721VersionEnum.ERC721V3, assetType.contract)];
                    case 2:
                        c = _a.sent();
                        callData = (0, types_1.toBinary)(c.functionCall.apply(c, (0, tslib_1.__spreadArray)(["safeTransferFrom"], transferArgs, false)).data);
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, (0, erc721_1.getErc721Contract)(ethereum, domain_1.ERC721VersionEnum.ERC721V2, assetType.contract)];
                    case 4:
                        c = _a.sent();
                        callData = (0, types_1.toBinary)(c.functionCall.apply(c, (0, tslib_1.__spreadArray)(["transferFrom"], transferArgs, false)).data);
                        _a.label = 5;
                    case 5: return [2 /*return*/, {
                            replacementPattern: isSellSide ? open_sea_converter_1.ERC721_MAKE_REPLACEMENT : open_sea_converter_1.ERC721_TAKE_REPLACEMENT,
                            target: assetType.contract,
                            callData: callData,
                        }];
                }
            });
        });
    };
    OpenSeaOrderHandler.prototype.getErc1155EncodedData = function (assetType, value, maker, isSellSide, validatorAddress) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var ethereum, startArgs, c, methodArgs, c, methodArgs;
            return (0, tslib_1.__generator)(this, function (_a) {
                ethereum = (0, get_required_wallet_1.getRequiredWallet)(this.ethereum);
                startArgs = [maker, types_1.ZERO_ADDRESS];
                if (!isSellSide) {
                    startArgs = [types_1.ZERO_ADDRESS, maker];
                }
                if (validatorAddress) {
                    c = (0, merkle_validator_1.createMerkleValidatorContract)(ethereum, validatorAddress);
                    methodArgs = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], startArgs, true), [assetType.contract, assetType.tokenId, value, "0x", []], false);
                    return [2 /*return*/, {
                            replacementPattern: isSellSide ? open_sea_converter_1.ERC1155_VALIDATOR_MAKE_REPLACEMENT : open_sea_converter_1.ERC1155_VALIDATOR_TAKE_REPLACEMENT,
                            target: validatorAddress,
                            callData: (0, types_1.toBinary)(c.functionCall.apply(c, (0, tslib_1.__spreadArray)(["matchERC1155UsingCriteria"], methodArgs, false)).data),
                        }];
                }
                else {
                    c = (0, erc1155_1.createErc1155Contract)(ethereum, assetType.contract);
                    methodArgs = (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], startArgs, true), [assetType.tokenId, value, "0x"], false);
                    return [2 /*return*/, {
                            replacementPattern: isSellSide ? open_sea_converter_1.ERC1155_MAKE_REPLACEMENT : open_sea_converter_1.ERC1155_TAKE_REPLACEMENT,
                            target: assetType.contract,
                            callData: (0, types_1.toBinary)(c.functionCall.apply(c, (0, tslib_1.__spreadArray)(["safeTransferFrom"], methodArgs, false)).data),
                        }];
                }
                return [2 /*return*/];
            });
        });
    };
    OpenSeaOrderHandler.prototype.getBaseOrderFee = function () {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                return [2 /*return*/, this.getBaseOrderFeeConfig("OPEN_SEA_V1")];
            });
        });
    };
    OpenSeaOrderHandler.prototype.getOrderFee = function (order) {
        if (order.data.feeRecipient === types_1.ZERO_ADDRESS) {
            return (0, utils_1.toBn)(order.data.takerProtocolFee).plus(order.data.takerRelayerFee).toNumber();
        }
        else {
            return (0, utils_1.toBn)(order.data.makerProtocolFee).plus(order.data.makerRelayerFee).toNumber();
        }
    };
    OpenSeaOrderHandler.prototype.approve = function (order, infinite) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var fee, assetWithFee, value, feeOnly;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fee = this.getOrderFee(order);
                        if (!(order.data.side === "BUY")) return [3 /*break*/, 2];
                        assetWithFee = (0, get_asset_with_fee_1.getAssetWithFee)(order.make, fee);
                        return [4 /*yield*/, (0, wait_tx_1.waitTx)(this.approveSingle(order.maker, assetWithFee, infinite))];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 2: return [4 /*yield*/, (0, wait_tx_1.waitTx)(this.approveSingle(order.maker, order.make, infinite))];
                    case 3:
                        _a.sent();
                        value = (0, utils_1.toBn)(order.take.value)
                            .multipliedBy(fee)
                            .dividedBy(10000)
                            .integerValue(utils_1.BigNumber.ROUND_FLOOR)
                            .toFixed();
                        feeOnly = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, order.take), { value: (0, types_1.toBigNumber)(value) });
                        return [4 /*yield*/, (0, wait_tx_1.waitTx)(this.approveSingle(order.maker, feeOnly, infinite))];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    OpenSeaOrderHandler.prototype.getTransactionData = function (initial, inverted) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, buy, sell, sellOrderToSignDTO, buyOrderToSignDTO, exchangeContract, buyVRS, sellVRS, ordersCanMatch, functionCall;
            var _b;
            return (0, tslib_1.__generator)(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!this.ethereum) {
                            throw new Error("Wallet undefined");
                        }
                        _a = getBuySellOrders(initial, inverted), buy = _a.buy, sell = _a.sell;
                        sellOrderToSignDTO = (0, open_sea_converter_1.convertOpenSeaOrderToDTO)(this.ethereum, sell);
                        buyOrderToSignDTO = (0, open_sea_converter_1.convertOpenSeaOrderToDTO)(this.ethereum, buy);
                        exchangeContract = (0, exchange_opensea_v1_1.createOpenseaContract)(this.ethereum, initial.data.exchange);
                        buyVRS = (0, to_vrs_1.toVrs)(buy.signature || "");
                        sellVRS = (0, to_vrs_1.toVrs)(sell.signature || "");
                        return [4 /*yield*/, exchangeContract
                                .functionCall("ordersCanMatch_", (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], getAtomicMatchArgAddresses(buyOrderToSignDTO), true), getAtomicMatchArgAddresses(sellOrderToSignDTO), true), (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], getAtomicMatchArgUints(buyOrderToSignDTO), true), getAtomicMatchArgUints(sellOrderToSignDTO), true), (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], getAtomicMatchArgCommonData(buyOrderToSignDTO), true), getAtomicMatchArgCommonData(sellOrderToSignDTO), true), buyOrderToSignDTO.calldata, sellOrderToSignDTO.calldata, buyOrderToSignDTO.replacementPattern, sellOrderToSignDTO.replacementPattern, buyOrderToSignDTO.staticExtradata, sellOrderToSignDTO.staticExtradata)
                                .call()];
                    case 1:
                        ordersCanMatch = _c.sent();
                        if (!ordersCanMatch) {
                            throw new Error("Orders cannot be matched");
                        }
                        functionCall = exchangeContract.functionCall("atomicMatch_", (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], getAtomicMatchArgAddresses(buyOrderToSignDTO), true), getAtomicMatchArgAddresses(sellOrderToSignDTO), true), (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], getAtomicMatchArgUints(buyOrderToSignDTO), true), getAtomicMatchArgUints(sellOrderToSignDTO), true), (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], getAtomicMatchArgCommonData(buyOrderToSignDTO), true), getAtomicMatchArgCommonData(sellOrderToSignDTO), true), buyOrderToSignDTO.calldata, sellOrderToSignDTO.calldata, buyOrderToSignDTO.replacementPattern, sellOrderToSignDTO.replacementPattern, buyOrderToSignDTO.staticExtradata, sellOrderToSignDTO.staticExtradata, [buyVRS.v, sellVRS.v], [buyVRS.r, buyVRS.s, sellVRS.r, sellVRS.s, this.getOrderMetadata()]);
                        _b = {
                            functionCall: functionCall
                        };
                        return [4 /*yield*/, getMatchOpenseaOptions(buy)];
                    case 2: return [2 /*return*/, (_b.options = _c.sent(),
                            _b)];
                }
            });
        });
    };
    OpenSeaOrderHandler.prototype.sendTransaction = function (initial, inverted) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, functionCall, options;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getTransactionData(initial, inverted)];
                    case 1:
                        _a = _b.sent(), functionCall = _a.functionCall, options = _a.options;
                        return [2 /*return*/, this.send(functionCall, options)];
                }
            });
        });
    };
    OpenSeaOrderHandler.prototype.approveSingle = function (maker, asset, infinite) {
        if (infinite === void 0) { infinite = true; }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, contract, operator, contract, proxyAddress, contract, proxyAddress;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.ethereum) {
                            throw new Error("Wallet undefined");
                        }
                        _a = asset.assetType.assetClass;
                        switch (_a) {
                            case "ERC20": return [3 /*break*/, 1];
                            case "ERC721": return [3 /*break*/, 2];
                            case "ERC1155": return [3 /*break*/, 4];
                        }
                        return [3 /*break*/, 6];
                    case 1:
                        {
                            contract = asset.assetType.contract;
                            operator = this.config.transferProxies.openseaV1;
                            return [2 /*return*/, (0, approve_erc20_1.approveErc20)(this.ethereum, this.send, contract, maker, operator, asset.value, infinite)];
                        }
                        _b.label = 2;
                    case 2:
                        contract = asset.assetType.contract;
                        return [4 /*yield*/, this.getRegisteredProxy(maker)];
                    case 3:
                        proxyAddress = _b.sent();
                        return [2 /*return*/, (0, approve_erc721_1.approveErc721)(this.ethereum, this.send, contract, maker, proxyAddress)];
                    case 4:
                        contract = asset.assetType.contract;
                        return [4 /*yield*/, this.getRegisteredProxy(maker)];
                    case 5:
                        proxyAddress = _b.sent();
                        return [2 /*return*/, (0, approve_erc1155_1.approveErc1155)(this.ethereum, this.send, contract, maker, proxyAddress)];
                    case 6: return [2 /*return*/, undefined];
                }
            });
        });
    };
    OpenSeaOrderHandler.prototype.getRegisteredProxy = function (maker) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var proxyRegistry, proxyRegistryContract, proxyAddress, registerTx;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.ethereum) {
                            throw new Error("Wallet undefined");
                        }
                        proxyRegistry = this.config.openSea.proxyRegistry;
                        proxyRegistryContract = (0, proxy_registry_opensea_1.createOpenseaProxyRegistryEthContract)(this.ethereum, proxyRegistry);
                        return [4 /*yield*/, getSenderProxy(proxyRegistryContract, maker)];
                    case 1:
                        proxyAddress = _a.sent();
                        if (!(proxyAddress === types_1.ZERO_ADDRESS)) return [3 /*break*/, 4];
                        return [4 /*yield*/, proxyRegistryContract.functionCall("registerProxy").send()];
                    case 2:
                        registerTx = _a.sent();
                        return [4 /*yield*/, registerTx.wait()];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, (0, exponential_backoff_1.backOff)(function () { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                                var value;
                                return (0, tslib_1.__generator)(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, getSenderProxy(proxyRegistryContract, maker)];
                                        case 1:
                                            value = _a.sent();
                                            if (value === types_1.ZERO_ADDRESS) {
                                                throw new Error("Expected non-zero proxy address");
                                            }
                                            return [2 /*return*/, value];
                                    }
                                });
                            }); }, {
                                maxDelay: 500,
                                numOfAttempts: 10,
                                delayFirstAttempt: true,
                                startingDelay: 100,
                            })];
                    case 4: return [2 /*return*/, proxyAddress];
                }
            });
        });
    };
    return OpenSeaOrderHandler;
}());
exports.OpenSeaOrderHandler = OpenSeaOrderHandler;
function getMatchOpenseaOptions(buy) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var fee, assetWithFee;
        return (0, tslib_1.__generator)(this, function (_a) {
            if (buy.make.assetType.assetClass === "ETH") {
                fee = (0, utils_1.toBn)(buy.data.takerProtocolFee).plus(buy.data.takerRelayerFee).toNumber();
                assetWithFee = (0, get_asset_with_fee_1.getAssetWithFee)(buy.make, fee);
                return [2 /*return*/, { value: assetWithFee.value }];
            }
            else {
                return [2 /*return*/, {}];
            }
            return [2 /*return*/];
        });
    });
}
function getSenderProxy(registryContract, sender) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var _a;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = types_1.toAddress;
                    return [4 /*yield*/, registryContract.functionCall("proxies", sender).call()];
                case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
            }
        });
    });
}
function getBuySellOrders(left, right) {
    if (left.data.side === "SELL") {
        return {
            buy: right,
            sell: left,
        };
    }
    else {
        return {
            buy: left,
            sell: right,
        };
    }
}
function getAtomicMatchArgAddresses(dto) {
    return [dto.exchange, dto.maker, dto.taker, dto.feeRecipient, dto.target, dto.staticTarget, dto.paymentToken];
}
exports.getAtomicMatchArgAddresses = getAtomicMatchArgAddresses;
function getAtomicMatchArgUints(dto) {
    return [
        dto.makerRelayerFee,
        dto.takerRelayerFee,
        dto.makerProtocolFee,
        dto.takerProtocolFee,
        dto.basePrice,
        dto.extra,
        dto.listingTime,
        dto.expirationTime,
        dto.salt,
    ];
}
exports.getAtomicMatchArgUints = getAtomicMatchArgUints;
function getAtomicMatchArgCommonData(dto) {
    return [dto.feeMethod, dto.side, dto.saleKind, dto.howToCall];
}
exports.getAtomicMatchArgCommonData = getAtomicMatchArgCommonData;
function getEthereumNetworkConfig(blockchain, sdkConfig) {
    if (!sdkConfig) {
        return;
    }
    switch (blockchain) {
        case "ETHEREUM": return sdkConfig.ethereum;
        case "POLYGON": return sdkConfig.polygon;
        default: return;
    }
}
var MATCH_ERC721_SAFE_TRANSFER_SIGNATURE = "0xc5a0236e";
var SAFE_TRANSFER_SIGNATURE = "0x42842e0e";
