"use strict";
// noinspection JSCommentMatchesSignature
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpsertOrder = void 0;
var tslib_1 = require("tslib");
var action_1 = require("@rarible/action");
var types_1 = require("@rarible/types");
var bn_1 = require("@rarible/utils/build/bn");
var cryptoPunks_1 = require("../nft/contracts/cryptoPunks");
var get_required_wallet_1 = require("../common/get-required-wallet");
var add_fee_1 = require("./add-fee");
var erc20_1 = require("./contracts/erc20");
var ZERO = (0, types_1.toWord)("0x0000000000000000000000000000000000000000000000000000000000000000");
var UpsertOrder = /** @class */ (function () {
    function UpsertOrder(orderFiller, send, checkLazyOrder, approveFn, signOrder, orderApi, ethereum, checkWalletChainId) {
        var _this = this;
        this.orderFiller = orderFiller;
        this.send = send;
        this.checkLazyOrder = checkLazyOrder;
        this.approveFn = approveFn;
        this.signOrder = signOrder;
        this.orderApi = orderApi;
        this.ethereum = ethereum;
        this.checkWalletChainId = checkWalletChainId;
        this.upsert = action_1.Action
            .create({
            id: "approve",
            run: function (_a) {
                var order = _a.order, infinite = _a.infinite;
                return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                    var checkedOrder;
                    return (0, tslib_1.__generator)(this, function (_b) {
                        switch (_b.label) {
                            case 0: return [4 /*yield*/, this.checkLazyOrder(order)];
                            case 1:
                                checkedOrder = _b.sent();
                                return [4 /*yield*/, this.approve(checkedOrder, infinite)];
                            case 2:
                                _b.sent();
                                return [2 /*return*/, checkedOrder];
                        }
                    });
                });
            },
        })
            .thenStep({
            id: "sign",
            run: function (checked) { return _this.upsertRequest(checked); },
        })
            .before(function (input) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.checkWalletChainId()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, input];
                }
            });
        }); });
    }
    UpsertOrder.prototype.getOrder = function (hasOrder) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                if ("order" in hasOrder) {
                    return [2 /*return*/, hasOrder.order];
                }
                else {
                    return [2 /*return*/, this.orderApi.getOrderByHash({ hash: hasOrder.orderHash })];
                }
                return [2 /*return*/];
            });
        });
    };
    UpsertOrder.prototype.getPrice = function (hasPrice, assetType) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a, decimals;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!("price" in hasPrice)) return [3 /*break*/, 1];
                        return [2 /*return*/, hasPrice.price];
                    case 1:
                        _a = assetType.assetClass;
                        switch (_a) {
                            case "ETH": return [3 /*break*/, 2];
                            case "ERC20": return [3 /*break*/, 3];
                        }
                        return [3 /*break*/, 5];
                    case 2: return [2 /*return*/, (0, bn_1.toBn)(hasPrice.priceDecimal).multipliedBy((0, bn_1.toBn)(10).pow(18))];
                    case 3: return [4 /*yield*/, (0, erc20_1.createErc20Contract)((0, get_required_wallet_1.getRequiredWallet)(this.ethereum), assetType.contract)
                            .functionCall("decimals")
                            .call()];
                    case 4:
                        decimals = _b.sent();
                        return [2 /*return*/, (0, bn_1.toBn)(hasPrice.priceDecimal).multipliedBy((0, bn_1.toBn)(10).pow(Number(decimals)))];
                    case 5: throw new Error("Asset type should be either ETH or ERC-20, received=".concat(JSON.stringify(assetType)));
                }
            });
        });
    };
    UpsertOrder.prototype.approve = function (checkedOrder, infinite) {
        if (infinite === void 0) { infinite = false; }
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var simple, fee, make;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        simple = UpsertOrder.orderFormToSimpleOrder(checkedOrder);
                        return [4 /*yield*/, this.orderFiller.getOrderFee(simple)];
                    case 1:
                        fee = _a.sent();
                        make = (0, add_fee_1.addFee)(checkedOrder.make, fee);
                        return [4 /*yield*/, this.approveFn(checkedOrder.maker, make, infinite)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    UpsertOrder.prototype.upsertRequest = function (checked) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var simple, _a, _b, _c;
            var _d, _e;
            return (0, tslib_1.__generator)(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        simple = UpsertOrder.orderFormToSimpleOrder(checked);
                        _b = (_a = this.orderApi).upsertOrder;
                        _d = {};
                        _c = [(0, tslib_1.__assign)({}, checked)];
                        _e = {};
                        return [4 /*yield*/, this.signOrder(simple)];
                    case 1: return [2 /*return*/, _b.apply(_a, [(_d.orderForm = tslib_1.__assign.apply(void 0, _c.concat([(_e.signature = _f.sent(), _e)])),
                                _d)])];
                }
            });
        });
    };
    UpsertOrder.prototype.prepareOrderForm = function (request, isMakeFill) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = {};
                        return [4 /*yield*/, this.getOrderMaker(request)];
                    case 1: return [2 /*return*/, (_a.maker = _b.sent(),
                            _a.type = "RARIBLE_V2",
                            _a.data = {
                                dataType: "RARIBLE_V2_DATA_V2",
                                payouts: request.payouts,
                                originFees: request.originFees,
                                isMakeFill: isMakeFill,
                            },
                            _a.salt = (0, types_1.toBigNumber)((0, bn_1.toBn)((0, types_1.randomWord)(), 16).toString(10)),
                            _a.signature = (0, types_1.toBinary)("0x"),
                            _a.start = request.start,
                            _a.end = request.end,
                            _a)];
                }
            });
        });
    };
    UpsertOrder.prototype.getOrderMaker = function (request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var _a;
            return (0, tslib_1.__generator)(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!request.maker) return [3 /*break*/, 1];
                        return [2 /*return*/, request.maker];
                    case 1:
                        _a = types_1.toAddress;
                        return [4 /*yield*/, (0, get_required_wallet_1.getRequiredWallet)(this.ethereum).getFrom()];
                    case 2: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
                }
            });
        });
    };
    UpsertOrder.orderFormToSimpleOrder = function (form) {
        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, form), { salt: (0, types_1.toBinary)((0, bn_1.toBn)(form.salt).toString(16)) });
    };
    UpsertOrder.prototype.getOrderFormFromOrder = function (order, make, take) {
        return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, order), { make: make, take: take, salt: (0, types_1.toBigNumber)((0, bn_1.toBn)(order.salt, 16).toString(10)), signature: order.signature || (0, types_1.toBinary)("0x") });
    };
    UpsertOrder.prototype.updateCryptoPunkOrder = function (request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var order;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getOrder(request)];
                    case 1:
                        order = _a.sent();
                        if (order.type !== "CRYPTO_PUNK") {
                            throw new Error("can't update punk order with type: ".concat(order.type));
                        }
                        return [4 /*yield*/, this.updateCryptoPunkOrderByContract((0, get_required_wallet_1.getRequiredWallet)(this.ethereum), order, request)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, simpleToCryptoPunkOrder(order)];
                }
            });
        });
    };
    UpsertOrder.prototype.updateCryptoPunkOrderByContract = function (ethereum, order, request) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var price, ethContract, ethContract;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getPrice(request, {})];
                    case 1:
                        price = _a.sent();
                        if (!(order.make.assetType.assetClass === "CRYPTO_PUNKS")) return [3 /*break*/, 3];
                        ethContract = (0, cryptoPunks_1.createCryptoPunksMarketContract)(ethereum, order.make.assetType.contract);
                        return [4 /*yield*/, this.send(ethContract.functionCall("offerPunkForSale", order.make.assetType.tokenId, price))];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 3:
                        if (!(order.take.assetType.assetClass === "CRYPTO_PUNKS")) return [3 /*break*/, 5];
                        ethContract = (0, cryptoPunks_1.createCryptoPunksMarketContract)(ethereum, order.take.assetType.contract);
                        return [4 /*yield*/, this.send(ethContract.functionCall("enterBidForPunk", order.take.assetType.tokenId), { value: price.toString() })];
                    case 4:
                        _a.sent();
                        return [3 /*break*/, 6];
                    case 5: throw new Error("Crypto punks asset has not been found");
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    return UpsertOrder;
}());
exports.UpsertOrder = UpsertOrder;
function simpleToCryptoPunkOrder(order) {
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, order), { cancelled: false, createdAt: "", fill: (0, types_1.toBigNumber)("0"), hash: ZERO, lastUpdateAt: "", makeStock: order.make.value });
}
