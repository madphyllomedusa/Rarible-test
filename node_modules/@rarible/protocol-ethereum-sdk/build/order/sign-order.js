"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.orderToStruct = exports.hashToSign = exports.signOrder = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var eth_sig_util_1 = require("eth-sig-util");
var hash_legacy_order_1 = require("./hash-legacy-order");
var asset_type_to_struct_1 = require("./asset-type-to-struct");
var eip712_1 = require("./eip712");
var encode_data_1 = require("./encode-data");
function signOrder(ethereum, config, order) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var _a, legacyHash, _b, domain, signature;
        return (0, tslib_1.__generator)(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!ethereum) {
                        throw new Error("Wallet undefined");
                    }
                    _a = order.type;
                    switch (_a) {
                        case "RARIBLE_V1": return [3 /*break*/, 1];
                        case "RARIBLE_V2": return [3 /*break*/, 3];
                    }
                    return [3 /*break*/, 5];
                case 1:
                    legacyHash = (0, hash_legacy_order_1.hashLegacyOrder)(ethereum, order);
                    _b = types_1.toBinary;
                    return [4 /*yield*/, ethereum.personalSign(legacyHash.substring(2))];
                case 2: return [2 /*return*/, _b.apply(void 0, [_c.sent()])];
                case 3:
                    domain = createEIP712Domain(config.chainId, config.exchange.v2);
                    return [4 /*yield*/, ethereum.signTypedData({
                            primaryType: eip712_1.EIP712_ORDER_TYPE,
                            domain: domain,
                            types: eip712_1.EIP712_ORDER_TYPES,
                            message: orderToStruct(ethereum, order),
                        })];
                case 4:
                    signature = _c.sent();
                    return [2 /*return*/, (0, types_1.toBinary)(signature)];
                case 5:
                    {
                        throw new Error("Unsupported order type: ".concat(order.type));
                    }
                    _c.label = 6;
                case 6: return [2 /*return*/];
            }
        });
    });
}
exports.signOrder = signOrder;
function hashToSign(config, ethereum, order) {
    var domain = createEIP712Domain(config.chainId, config.exchange.v2);
    return eth_sig_util_1.TypedDataUtils.sign({
        primaryType: eip712_1.EIP712_ORDER_TYPE,
        domain: domain,
        types: eip712_1.EIP712_ORDER_TYPES,
        message: orderToStruct(ethereum, order),
    });
}
exports.hashToSign = hashToSign;
function createEIP712Domain(chainId, verifyingContract) {
    return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, eip712_1.EIP712_DOMAIN_TEMPLATE), { verifyingContract: verifyingContract, chainId: chainId });
}
function orderToStruct(ethereum, order, wrongEncode) {
    var _a, _b, _c;
    if (wrongEncode === void 0) { wrongEncode = false; }
    var _d = (0, encode_data_1.encodeData)(ethereum, order.data, wrongEncode), dataType = _d[0], data = _d[1];
    return {
        maker: order.maker,
        makeAsset: assetToStruct(ethereum, order.make),
        taker: (_a = order.taker) !== null && _a !== void 0 ? _a : types_1.ZERO_ADDRESS,
        takeAsset: assetToStruct(ethereum, order.take),
        salt: order.salt,
        start: (_b = order.start) !== null && _b !== void 0 ? _b : 0,
        end: (_c = order.end) !== null && _c !== void 0 ? _c : 0,
        dataType: dataType,
        data: data,
    };
}
exports.orderToStruct = orderToStruct;
function assetToStruct(ethereum, asset) {
    return {
        assetType: (0, asset_type_to_struct_1.assetTypeToStruct)(ethereum, asset.assetType),
        value: asset.value,
    };
}
