"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cancelCryptoPunkOrderByAsset = exports.cancelCryptoPunksOrder = exports.cancelOpenseaOrderV1 = exports.cancel = void 0;
var tslib_1 = require("tslib");
var to_vrs_1 = require("../common/to-vrs");
var cryptoPunks_1 = require("../nft/contracts/cryptoPunks");
var exchange_v1_1 = require("./contracts/exchange-v1");
var exchange_v2_1 = require("./contracts/exchange-v2");
var exchange_opensea_v1_1 = require("./contracts/exchange-opensea-v1");
var rarible_v1_1 = require("./fill-order/rarible-v1");
var open_sea_1 = require("./fill-order/open-sea");
var sign_order_1 = require("./sign-order");
var open_sea_converter_1 = require("./fill-order/open-sea-converter");
function cancel(checkLazyOrder, ethereum, send, config, checkWalletChainId, orderToCheck) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var order;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, checkWalletChainId()];
                case 1:
                    _a.sent();
                    if (!ethereum) return [3 /*break*/, 3];
                    return [4 /*yield*/, checkLazyOrder(orderToCheck)];
                case 2:
                    order = _a.sent();
                    switch (order.type) {
                        case "RARIBLE_V1":
                            return [2 /*return*/, cancelLegacyOrder(ethereum, send, config.v1, order)];
                        case "RARIBLE_V2":
                            return [2 /*return*/, cancelV2Order(ethereum, send, config.v2, order)];
                        case "OPEN_SEA_V1":
                            return [2 /*return*/, cancelOpenseaOrderV1(ethereum, send, order)];
                        case "CRYPTO_PUNK":
                            return [2 /*return*/, cancelCryptoPunksOrder(ethereum, send, order)];
                        default:
                            throw new Error("Unsupported order: ".concat(JSON.stringify(order)));
                    }
                    _a.label = 3;
                case 3: throw new Error("Wallet undefined");
            }
        });
    });
}
exports.cancel = cancel;
function cancelLegacyOrder(ethereum, send, contract, order) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var v1;
        return (0, tslib_1.__generator)(this, function (_a) {
            v1 = (0, exchange_v1_1.createExchangeV1Contract)(ethereum, contract);
            return [2 /*return*/, send(v1.functionCall("cancel", (0, rarible_v1_1.toStructLegacyOrderKey)(order)))];
        });
    });
}
function cancelV2Order(ethereum, send, contract, order) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var v2;
        return (0, tslib_1.__generator)(this, function (_a) {
            v2 = (0, exchange_v2_1.createExchangeV2Contract)(ethereum, contract);
            return [2 /*return*/, send(v2.functionCall("cancel", (0, sign_order_1.orderToStruct)(ethereum, order)))];
        });
    });
}
function cancelOpenseaOrderV1(ethereum, send, order) {
    var exchangeContract = (0, exchange_opensea_v1_1.createOpenseaContract)(ethereum, order.data.exchange);
    var dto = (0, open_sea_converter_1.convertOpenSeaOrderToDTO)(ethereum, order);
    var makerVRS = (0, to_vrs_1.toVrs)(order.signature || "0x");
    return send(exchangeContract.functionCall("cancelOrder_", (0, open_sea_1.getAtomicMatchArgAddresses)(dto), (0, open_sea_1.getAtomicMatchArgUints)(dto), dto.feeMethod, dto.side, dto.saleKind, dto.howToCall, dto.calldata, dto.replacementPattern, dto.staticExtradata, makerVRS.v, makerVRS.r, makerVRS.s));
}
exports.cancelOpenseaOrderV1 = cancelOpenseaOrderV1;
function cancelCryptoPunksOrder(ethereum, send, order) {
    if (order.make.assetType.assetClass === "CRYPTO_PUNKS") {
        return cancelCryptoPunkOrderByAsset(ethereum, send, "punkNoLongerForSale", order.make.assetType);
    }
    else if (order.take.assetType.assetClass === "CRYPTO_PUNKS") {
        return cancelCryptoPunkOrderByAsset(ethereum, send, "withdrawBidForPunk", order.take.assetType);
    }
    else {
        throw new Error("Crypto punks asset has not been found");
    }
}
exports.cancelCryptoPunksOrder = cancelCryptoPunksOrder;
function cancelCryptoPunkOrderByAsset(ethereum, send, methodName, assetType) {
    var ethContract = (0, cryptoPunks_1.createCryptoPunksMarketContract)(ethereum, assetType.contract);
    return send(ethContract.functionCall(methodName, assetType.tokenId));
}
exports.cancelCryptoPunkOrderByAsset = cancelCryptoPunkOrderByAsset;
