"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.approveCryptoPunk = void 0;
var tslib_1 = require("tslib");
var cryptoPunks_1 = require("../nft/contracts/cryptoPunks");
function approveCryptoPunk(ethereum, send, contractAddress, owner, operator, punkIndex) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var marketContract, offer;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!ethereum) {
                        throw new Error("Wallet undefined");
                    }
                    marketContract = (0, cryptoPunks_1.createCryptoPunksMarketContract)(ethereum, contractAddress);
                    return [4 /*yield*/, marketContract.functionCall("punksOfferedForSale", punkIndex).call()];
                case 1:
                    offer = _a.sent();
                    if (offer.isForSale && offer.onlySellTo.toLowerCase() === operator.toLowerCase() && offer.minValue === "0") {
                        return [2 /*return*/, undefined];
                    }
                    else {
                        return [2 /*return*/, send(marketContract.functionCall("offerPunkForSaleToAddress", punkIndex, 0, operator))];
                    }
                    return [2 /*return*/];
            }
        });
    });
}
exports.approveCryptoPunk = approveCryptoPunk;
