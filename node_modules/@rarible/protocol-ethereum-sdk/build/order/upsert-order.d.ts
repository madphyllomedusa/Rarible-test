import type { Binary, Erc20AssetType, EthAssetType, Order, OrderControllerApi, OrderForm, Part, RaribleV2OrderForm } from "@rarible/ethereum-api-client";
import { Action } from "@rarible/action";
import type { Address, Word } from "@rarible/types";
import type { BigNumberValue } from "@rarible/utils/build/bn";
import type { Ethereum } from "@rarible/ethereum-provider";
import type { Maybe } from "@rarible/types/build/maybe";
import type { SendFunction } from "../common/send-transaction";
import type { SimpleOrder, UpsertSimpleOrder } from "./types";
import type { ApproveFunction } from "./approve";
import type { OrderFiller } from "./fill-order";
import type { CheckLazyOrderPart } from "./check-lazy-order";
import type { SellUpdateRequest } from "./sell";
export declare type UpsertOrderStageId = "approve" | "sign";
export declare type UpsertOrderActionArg = {
    order: OrderForm;
    infinite?: boolean;
};
export declare type UpsertOrderAction = Action<UpsertOrderStageId, UpsertOrderActionArg, Order>;
export declare type HasOrder = {
    orderHash: Word;
} | {
    order: SimpleOrder;
};
export declare type HasPrice = {
    price: BigNumberValue;
} | {
    priceDecimal: BigNumberValue;
};
export declare type OrderRequest = {
    maker?: Address;
    payouts: Part[];
    originFees: Part[];
    start?: number;
    end?: number;
};
export declare class UpsertOrder {
    private readonly orderFiller;
    private readonly send;
    readonly checkLazyOrder: (form: CheckLazyOrderPart) => Promise<CheckLazyOrderPart>;
    private readonly approveFn;
    private readonly signOrder;
    private readonly orderApi;
    private readonly ethereum;
    private readonly checkWalletChainId;
    constructor(orderFiller: OrderFiller, send: SendFunction, checkLazyOrder: (form: CheckLazyOrderPart) => Promise<CheckLazyOrderPart>, approveFn: ApproveFunction, signOrder: (order: SimpleOrder) => Promise<Binary>, orderApi: OrderControllerApi, ethereum: Maybe<Ethereum>, checkWalletChainId: () => Promise<boolean>);
    readonly upsert: Action<"approve" | "sign", UpsertOrderActionArg, Order>;
    getOrder(hasOrder: HasOrder): Promise<SimpleOrder>;
    getPrice(hasPrice: HasPrice, assetType: Erc20AssetType | EthAssetType): Promise<BigNumberValue>;
    approve(checkedOrder: OrderForm, infinite?: boolean): Promise<void>;
    upsertRequest(checked: OrderForm): Promise<Order>;
    prepareOrderForm(request: OrderRequest, isMakeFill: boolean): Promise<Omit<RaribleV2OrderForm, "take" | "make">>;
    private getOrderMaker;
    static orderFormToSimpleOrder(form: OrderForm): SimpleOrder;
    getOrderFormFromOrder<T extends UpsertSimpleOrder>(order: T, make: T["make"], take: T["take"]): OrderForm;
    updateCryptoPunkOrder(request: SellUpdateRequest): Promise<Order>;
    private updateCryptoPunkOrderByContract;
}
