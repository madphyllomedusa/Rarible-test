"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForHash = exports.sentTx = exports.createPendingLogs = exports.getSimpleSendWithInjects = exports.getSendWithInjects = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var types_2 = require("../types");
var logger_1 = require("./logger/logger");
function getSendWithInjects(injects) {
    if (injects === void 0) { injects = {}; }
    var logger = injects.logger;
    return function send(api, checkChainId, functionCall, options) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var callInfo, logsAvailable, tx, e_1, err_1;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, checkChainId()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, functionCall.getCallInfo()];
                    case 2:
                        callInfo = _a.sent();
                        logsAvailable = logger && logger.level && callInfo;
                        _a.label = 3;
                    case 3:
                        _a.trys.push([3, 9, , 10]);
                        return [4 /*yield*/, functionCall.send(options)];
                    case 4:
                        tx = _a.sent();
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, 7, , 8]);
                        return [4 /*yield*/, createPendingLogs(api, tx)];
                    case 6:
                        _a.sent();
                        return [3 /*break*/, 8];
                    case 7:
                        e_1 = _a.sent();
                        console.error("createPendingLogs error", e_1);
                        return [3 /*break*/, 8];
                    case 8:
                        try {
                            if (logsAvailable && logger.level >= types_2.LogsLevel.TRACE) {
                                logger.instance.trace(callInfo.method, {
                                    from: callInfo.from,
                                    args: callInfo.args,
                                    tx: tx,
                                });
                            }
                        }
                        catch (e) {
                            console.error("Error while sending logs", e);
                        }
                        return [2 /*return*/, tx];
                    case 9:
                        err_1 = _a.sent();
                        try {
                            if (logsAvailable && logger.level >= types_2.LogsLevel.ERROR && callInfo) {
                                logger.instance.error(callInfo.method, {
                                    from: callInfo.from,
                                    args: callInfo.args,
                                    error: (0, logger_1.getErrorMessageString)(err_1),
                                });
                            }
                        }
                        catch (e) {
                            console.error("Error while sending logs", e, err_1);
                        }
                        throw err_1;
                    case 10: return [2 /*return*/];
                }
            });
        });
    };
}
exports.getSendWithInjects = getSendWithInjects;
function getSimpleSendWithInjects(injects) {
    if (injects === void 0) { injects = {}; }
    var logger = injects.logger;
    return function simpleSend(checkChainId, functionCall, options) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var callInfo, logsAvailable, tx;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, functionCall.getCallInfo()];
                    case 1:
                        callInfo = _a.sent();
                        logsAvailable = logger && logger.level && callInfo;
                        try {
                            tx = functionCall.send(options);
                            try {
                                if (logsAvailable && logger.level >= types_2.LogsLevel.TRACE) {
                                    logger.instance.trace(callInfo.method, {
                                        from: callInfo.from,
                                        args: callInfo.args,
                                        tx: tx,
                                    });
                                }
                            }
                            catch (e) {
                                console.error("Error while sending logs", e);
                            }
                            return [2 /*return*/, tx];
                        }
                        catch (err) {
                            try {
                                if (logsAvailable && logger.level >= types_2.LogsLevel.ERROR && callInfo) {
                                    logger.instance.error(callInfo.method, {
                                        from: callInfo.from,
                                        args: callInfo.args,
                                        error: (0, logger_1.getErrorMessageString)(err),
                                    });
                                }
                            }
                            catch (e) {
                                console.error("Error while sending logs", e, err);
                            }
                            throw err;
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
}
exports.getSimpleSendWithInjects = getSimpleSendWithInjects;
function createPendingLogs(api, tx) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var createTransactionRequest;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    createTransactionRequest = {
                        hash: (0, types_1.toWord)(tx.hash),
                        from: (0, types_1.toAddress)(tx.from),
                        to: tx.to ? (0, types_1.toAddress)(tx.to) : undefined,
                        input: (0, types_1.toBinary)(tx.data),
                        nonce: tx.nonce,
                    };
                    return [4 /*yield*/, api.createGatewayPendingTransactions({ createTransactionRequest: createTransactionRequest })];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
exports.createPendingLogs = createPendingLogs;
function sentTx(source, options) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var event;
        return (0, tslib_1.__generator)(this, function (_a) {
            event = source.send((0, tslib_1.__assign)((0, tslib_1.__assign)({}, options), { gas: 3000000 }));
            return [2 /*return*/, waitForHash(event)];
        });
    });
}
exports.sentTx = sentTx;
function waitForHash(promiEvent) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        return (0, tslib_1.__generator)(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    promiEvent.on("transactionHash", function (hash) { return resolve(hash); });
                    promiEvent.on("error", function (error) { return reject(error); });
                })];
        });
    });
}
exports.waitForHash = waitForHash;
