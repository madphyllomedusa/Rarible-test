"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSigner = void 0;
var tslib_1 = require("tslib");
var ethereumjs_util_1 = require("ethereumjs-util");
function isSigner(ethereum, signer, hash, signature) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var sig;
        return (0, tslib_1.__generator)(this, function (_a) {
            sig = Buffer.from(skip0x(signature), "hex");
            if (sig.length >= 64 && recover(hash, sig) === signer) {
                return [2 /*return*/, true];
            }
            return [2 /*return*/, isErc1271Signer(ethereum, signer, hash, signature)];
        });
    });
}
exports.isSigner = isSigner;
function isErc1271Signer(ethereum, signer, hash, signature) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var hashHex, erc1271, result, ex_1;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    hashHex = "0x".concat(hash.toString("hex"));
                    console.log("checking signer using erc-1271", hashHex);
                    erc1271 = ethereum.createContract(ABI, signer);
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, erc1271.functionCall("isValidSignature", hashHex, signature).call()];
                case 2:
                    result = _a.sent();
                    if (result !== "0x1626ba7e") {
                        console.warn("isValidSignature result is ".concat(result));
                        return [2 /*return*/, false];
                    }
                    return [2 /*return*/, true];
                case 3:
                    ex_1 = _a.sent();
                    console.error("unable to check signature", ex_1);
                    return [2 /*return*/, false];
                case 4: return [2 /*return*/];
            }
        });
    });
}
var ABI = [
    {
        "inputs": [
            {
                "internalType": "bytes32",
                "name": "_hash",
                "type": "bytes32",
            },
            {
                "internalType": "bytes",
                "name": "_signature",
                "type": "bytes",
            },
        ],
        "name": "isValidSignature",
        "outputs": [
            {
                "internalType": "bytes4",
                "name": "",
                "type": "bytes4",
            },
        ],
        "stateMutability": "view",
        "type": "function",
    },
];
function recover(initialHash, signature) {
    var sig = fromRpcSig(signature);
    var _a = fixHashAndV(sig.v, initialHash), hash = _a[0], v = _a[1];
    return (0, ethereumjs_util_1.bufferToHex)((0, ethereumjs_util_1.pubToAddress)((0, ethereumjs_util_1.ecrecover)(hash, v, sig.r, sig.s)));
}
function fixHashAndV(v, hash) {
    if (v === 0 || v === 1) {
        return [hash, 27 + v];
    }
    else if (v === 27 || v === 28) {
        return [hash, v];
    }
    else if (v === 32 || v === 31) {
        return [getEthSignedMessageHash(hash), v - 4];
    }
    else {
        throw new Error("Value of 'v' is not recognised: ".concat(v));
    }
}
var START = "\u0019Ethereum Signed Message:\n";
function getEthSignedMessageHash(hash) {
    return (0, ethereumjs_util_1.keccak256)(Buffer.concat([Buffer.from("".concat(START, "32"), "ascii"), hash]));
}
function fromRpcSig(buf) {
    var r;
    var s;
    var v;
    if (buf.length >= 65) {
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, ethereumjs_util_1.bufferToInt)(buf.slice(64));
    }
    else if (buf.length === 64) {
        // Compact Signature Representation (https://eips.ethereum.org/EIPS/eip-2098)
        r = buf.slice(0, 32);
        s = buf.slice(32, 64);
        v = (0, ethereumjs_util_1.bufferToInt)(buf.slice(32, 33)) >> 7;
        s[0] &= 0x7f;
    }
    else {
        throw new Error("Invalid signature length");
    }
    // support both versions of `eth_sign` responses
    if (v < 27) {
        v += 27;
    }
    return {
        v: v,
        r: r,
        s: s,
    };
}
function skip0x(hex) {
    if (hex.startsWith("0x")) {
        return hex.substring(2);
    }
    else {
        return hex;
    }
}
