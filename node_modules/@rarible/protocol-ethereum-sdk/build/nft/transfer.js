"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transfer = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var bn_1 = require("@rarible/utils/build/bn");
var get_ownership_id_1 = require("../common/get-ownership-id");
var transfer_erc721_1 = require("./transfer-erc721");
var transfer_erc1155_1 = require("./transfer-erc1155");
var transfer_nft_lazy_1 = require("./transfer-nft-lazy");
var transfer_crypto_punk_1 = require("./transfer-crypto-punk");
function transfer(ethereum, send, checkAssetType, nftItemApi, nftOwnershipApi, checkWalletChainId, initialAsset, to, amount) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var from, _a, ownership, asset;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, checkWalletChainId()];
                case 1:
                    _b.sent();
                    if (!ethereum) {
                        throw new Error("Wallet undefined");
                    }
                    _a = types_1.toAddress;
                    return [4 /*yield*/, ethereum.getFrom()];
                case 2:
                    from = _a.apply(void 0, [_b.sent()]);
                    return [4 /*yield*/, nftOwnershipApi.getNftOwnershipByIdRaw({
                            ownershipId: (0, get_ownership_id_1.getOwnershipId)(initialAsset.contract, (0, types_1.toBigNumber)("".concat(initialAsset.tokenId)), from),
                        })];
                case 3:
                    ownership = _b.sent();
                    if (!(ownership.status === 200)) return [3 /*break*/, 5];
                    return [4 /*yield*/, checkAssetType(initialAsset)];
                case 4:
                    asset = _b.sent();
                    if ((0, bn_1.toBn)(ownership.value.lazyValue).gt(0)) {
                        if (asset.assetClass === "CRYPTO_PUNKS") {
                            throw new Error("CRYPTO_PUNKS can't be lazy");
                        }
                        if (asset.assetClass === "COLLECTION") {
                            throw new Error("Transfer asset class cannot be as collection");
                        }
                        return [2 /*return*/, (0, transfer_nft_lazy_1.transferNftLazy)(ethereum, send, nftItemApi, asset, (0, types_1.toAddress)(from), to, amount)];
                    }
                    switch (asset.assetClass) {
                        case "ERC721": return [2 /*return*/, (0, transfer_erc721_1.transferErc721)(ethereum, send, asset.contract, from, to, asset.tokenId)];
                        case "ERC1155": return [2 /*return*/, (0, transfer_erc1155_1.transferErc1155)(ethereum, send, asset.contract, from, to, asset.tokenId, amount || "1")];
                        case "CRYPTO_PUNKS": return [2 /*return*/, (0, transfer_crypto_punk_1.transferCryptoPunk)(ethereum, send, asset.contract, to, asset.tokenId)];
                        default:
                            throw new Error("Not supported asset: ".concat(JSON.stringify(asset)));
                    }
                    return [3 /*break*/, 6];
                case 5: throw new Error("Address ".concat(from, " has not any ownerships of token with Id ").concat(initialAsset.tokenId));
                case 6: return [2 /*return*/];
            }
        });
    });
}
exports.transfer = transfer;
