"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.burn = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var utils_1 = require("@rarible/utils");
var get_ownership_id_1 = require("../common/get-ownership-id");
var create_item_id_1 = require("../common/create-item-id");
var erc721_1 = require("./contracts/erc721");
var domain_1 = require("./contracts/domain");
var erc1155_1 = require("./contracts/erc1155");
function burn(ethereum, send, checkAssetType, apis, checkWalletChainId, request) {
    var _a;
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var checked, from, _b, ownership, lazyValueBn, creators, _c, _d, _e, _f, erc721Contract, erc1155Contract, owner;
        var _g, _h;
        return (0, tslib_1.__generator)(this, function (_j) {
            switch (_j.label) {
                case 0: return [4 /*yield*/, checkWalletChainId()];
                case 1:
                    _j.sent();
                    if (!ethereum) {
                        throw new Error("Wallet undefined");
                    }
                    return [4 /*yield*/, checkAssetType(request.assetType)];
                case 2:
                    checked = _j.sent();
                    _b = types_1.toAddress;
                    return [4 /*yield*/, ethereum.getFrom()];
                case 3:
                    from = _b.apply(void 0, [_j.sent()]);
                    return [4 /*yield*/, apis.nftOwnership.getNftOwnershipByIdRaw({
                            ownershipId: (0, get_ownership_id_1.getOwnershipId)(request.assetType.contract, (0, types_1.toBigNumber)("".concat(request.assetType.tokenId)), from),
                        })];
                case 4:
                    ownership = _j.sent();
                    if (!(ownership.status === 200)) return [3 /*break*/, 14];
                    lazyValueBn = (0, utils_1.toBn)(ownership.value.lazyValue);
                    if (!lazyValueBn.gt(0)) return [3 /*break*/, 6];
                    if (!lazyValueBn.isEqualTo(ownership.value.value)) {
                        throw new Error("Unable to burn lazy minted item");
                    }
                    creators = !request.creators || !request.creators.length
                        ? [from]
                        : (_a = request.creators) === null || _a === void 0 ? void 0 : _a.map(function (creator) { return creator.account; });
                    _d = (_c = apis.nftItem).deleteLazyMintNftAsset;
                    _g = {
                        itemId: (0, create_item_id_1.createItemId)(request.assetType.contract, (0, types_1.toBigNumber)("".concat(request.assetType.tokenId)))
                    };
                    _h = {
                        creators: creators
                    };
                    _e = types_1.toBinary;
                    return [4 /*yield*/, ethereum.personalSign("I would like to burn my ".concat(request.assetType.tokenId, " item."))];
                case 5: return [2 /*return*/, _d.apply(_c, [(_g.burnLazyNftForm = (_h.signatures = [
                            _e.apply(void 0, [_j.sent()])
                        ],
                            _h),
                            _g)])];
                case 6:
                    _f = checked.assetClass;
                    switch (_f) {
                        case "ERC721": return [3 /*break*/, 7];
                        case "ERC1155": return [3 /*break*/, 9];
                    }
                    return [3 /*break*/, 13];
                case 7: return [4 /*yield*/, (0, erc721_1.getErc721Contract)(ethereum, domain_1.ERC721VersionEnum.ERC721V2, checked.contract)];
                case 8:
                    erc721Contract = _j.sent();
                    return [2 /*return*/, send(erc721Contract.functionCall("burn", checked.tokenId))];
                case 9:
                    if (!request.amount) return [3 /*break*/, 12];
                    return [4 /*yield*/, (0, erc1155_1.getErc1155Contract)(ethereum, domain_1.ERC1155VersionEnum.ERC1155V1, checked.contract)];
                case 10:
                    erc1155Contract = _j.sent();
                    return [4 /*yield*/, ethereum.getFrom()];
                case 11:
                    owner = _j.sent();
                    return [2 /*return*/, send(erc1155Contract.functionCall("burn", owner, checked.tokenId, request.amount))];
                case 12: throw new Error("amount is ".concat(request.amount, ". Amount for burn ERC1155 is required"));
                case 13: throw new Error("Unexpected asset class");
                case 14: throw new Error("Ownership is not found");
            }
        });
    });
}
exports.burn = burn;
