"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signNft = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var eip712_1 = require("./eip712");
function signNft(ethereum, chainId, nft) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var _a, domain, data, _b, domain, data, _c;
        return (0, tslib_1.__generator)(this, function (_d) {
            switch (_d.label) {
                case 0:
                    if (!ethereum) {
                        throw new Error("Wallet undefined");
                    }
                    _a = nft["@type"];
                    switch (_a) {
                        case "ERC721": return [3 /*break*/, 1];
                        case "ERC1155": return [3 /*break*/, 3];
                    }
                    return [3 /*break*/, 5];
                case 1:
                    domain = createEIP712NftDomain(chainId, nft.contract, "ERC721");
                    data = {
                        types: eip712_1.EIP721_NFT_TYPES,
                        domain: domain,
                        primaryType: eip712_1.EIP721_NFT_TYPE,
                        message: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, nft), { tokenURI: nft.uri }),
                    };
                    _b = types_1.toBinary;
                    return [4 /*yield*/, ethereum.signTypedData(data)];
                case 2: return [2 /*return*/, _b.apply(void 0, [_d.sent()])];
                case 3:
                    domain = createEIP712NftDomain(chainId, nft.contract, "ERC1155");
                    data = {
                        types: eip712_1.EIP1155_NFT_TYPES,
                        domain: domain,
                        primaryType: eip712_1.EIP1155_NFT_TYPE,
                        message: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, nft), { tokenURI: nft.uri }),
                    };
                    _c = types_1.toBinary;
                    return [4 /*yield*/, ethereum.signTypedData(data)];
                case 4: return [2 /*return*/, _c.apply(void 0, [_d.sent()])];
                case 5:
                    {
                        throw new Error("Unexpected");
                    }
                    _d.label = 6;
                case 6: return [2 /*return*/];
            }
        });
    });
}
exports.signNft = signNft;
function createEIP712NftDomain(chainId, verifyingContract, nftType) {
    switch (nftType) {
        case "ERC721": {
            return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, eip712_1.EIP721_DOMAIN_NFT_TEMPLATE), { chainId: chainId, verifyingContract: verifyingContract });
        }
        case "ERC1155": {
            return (0, tslib_1.__assign)((0, tslib_1.__assign)({}, eip712_1.EIP1155_DOMAIN_NFT_TEMPLATE), { chainId: chainId, verifyingContract: verifyingContract });
        }
        default: {
            throw new Error("Unexpected");
        }
    }
}
