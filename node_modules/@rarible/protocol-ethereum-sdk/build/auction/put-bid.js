"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PutAuctionBid = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var ethereum_api_client_1 = require("@rarible/ethereum-api-client");
var action_1 = require("@rarible/action");
var utils_1 = require("@rarible/utils");
var wait_tx_1 = require("../common/wait-tx");
var get_price_1 = require("../common/get-price");
var check_chain_id_1 = require("../order/check-chain-id");
var validate_part_1 = require("../common/validate-part");
var get_base_fee_1 = require("../common/get-base-fee");
var auction_1 = require("./contracts/auction");
var common_1 = require("./common");
var PutAuctionBid = /** @class */ (function () {
    function PutAuctionBid(ethereum, send, config, env, approve, apis) {
        var _this = this;
        this.ethereum = ethereum;
        this.send = send;
        this.config = config;
        this.env = env;
        this.approve = approve;
        this.apis = apis;
        this.putBid = action_1.Action.create({
            id: "approve",
            run: function (request) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                var auction, price, _a, _b, _c, _d;
                return (0, tslib_1.__generator)(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            if (!this.ethereum) {
                                throw new Error("Wallet is undefined");
                            }
                            return [4 /*yield*/, this.apis.auction.getAuctionByHash({ hash: request.hash })];
                        case 1:
                            auction = _e.sent();
                            this.validate(request, auction);
                            _a = types_1.toBigNumber;
                            return [4 /*yield*/, (0, get_price_1.getPrice)(this.ethereum, auction.buy, request.priceDecimal)];
                        case 2:
                            price = _a.apply(void 0, [(_e.sent()).toString()]);
                            if (!(auction.buy.assetClass !== "ETH")) return [3 /*break*/, 5];
                            _b = wait_tx_1.waitTx;
                            _c = this.approve;
                            _d = types_1.toAddress;
                            return [4 /*yield*/, this.ethereum.getFrom()];
                        case 3: return [4 /*yield*/, _b.apply(void 0, [_c.apply(this, [_d.apply(void 0, [_e.sent()]),
                                    { assetType: auction.buy, value: price },
                                    true])])];
                        case 4:
                            _e.sent();
                            _e.label = 5;
                        case 5: return [2 /*return*/, { request: request, auction: auction, price: price }];
                    }
                });
            }); },
        })
            .thenStep({
            id: "sign",
            run: function (_a) {
                var request = _a.request, auction = _a.auction, price = _a.price;
                return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                    var bidderOriginFees, bidData, bid, protocolFee, totalFees, options, contract;
                    return (0, tslib_1.__generator)(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                if (!this.ethereum) {
                                    throw new Error("Wallet is undefined");
                                }
                                bidderOriginFees = request.originFees || [];
                                bidData = this.ethereum.encodeParameter(common_1.AUCTION_BID_DATA_V1, {
                                    payouts: [],
                                    originFees: bidderOriginFees,
                                });
                                bid = {
                                    amount: price,
                                    dataType: common_1.AUCTION_DATA_TYPE,
                                    data: bidData,
                                };
                                return [4 /*yield*/, this.getBaseFee()];
                            case 1:
                                protocolFee = _b.sent();
                                totalFees = (0, common_1.calculatePartsSum)(bidderOriginFees.concat(auction.data.originFees)) + protocolFee;
                                options = (0, common_1.getAuctionOperationOptions)(auction.buy, price, totalFees);
                                contract = (0, auction_1.createEthereumAuctionContract)(this.ethereum, this.config.auction);
                                return [2 /*return*/, this.send(contract.functionCall("putBid", auction.auctionId, bid), options)];
                        }
                    });
                });
            },
        })
            .before(function (request) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, check_chain_id_1.checkChainId)(this.ethereum, this.config)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, request];
                }
            });
        }); });
        this.getBaseFee = get_base_fee_1.getBaseFee.bind(null, config, env, "AUCTION");
    }
    PutAuctionBid.prototype.validate = function (request, auction) {
        if (auction.status !== ethereum_api_client_1.AuctionStatus.ACTIVE) {
            throw new Error("Auction status is ".concat(auction.status, ", expected ").concat(ethereum_api_client_1.AuctionStatus.ACTIVE));
        }
        var price = (0, utils_1.toBn)(request.priceDecimal);
        if (price.isNaN() || !price.isPositive()) {
            throw new Error("Wrong bid price");
        }
        if (auction.lastBid) {
            var lastBid = (0, utils_1.toBn)(auction.lastBid.amount);
            var minimalNextPrice = lastBid.plus(auction.minimalStep);
            if (minimalNextPrice.isLessThan(price)) {
                throw new Error("Bid price should be greater");
            }
        }
        else {
            if (price.isLessThan(auction.minimalPrice)) {
                throw new Error("Bid price should be greater than minimal price");
            }
        }
        (0, validate_part_1.validateParts)(request.originFees);
        return true;
    };
    return PutAuctionBid;
}());
exports.PutAuctionBid = PutAuctionBid;
