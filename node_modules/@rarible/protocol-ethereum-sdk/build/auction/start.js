"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StartAuction = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var action_1 = require("@rarible/action");
var utils_1 = require("@rarible/utils");
var id_1 = require("../common/id");
var wait_tx_1 = require("../common/wait-tx");
var get_price_1 = require("../common/get-price");
var check_asset_type_1 = require("../order/check-asset-type");
var check_chain_id_1 = require("../order/check-chain-id");
var is_nft_1 = require("../order/is-nft");
var is_payment_token_1 = require("../common/is-payment-token");
var validate_part_1 = require("../common/validate-part");
var auction_1 = require("./contracts/auction");
var common_1 = require("./common");
var StartAuction = /** @class */ (function () {
    function StartAuction(ethereum, send, config, env, approve, apis) {
        var _this = this;
        this.ethereum = ethereum;
        this.send = send;
        this.config = config;
        this.env = env;
        this.approve = approve;
        this.apis = apis;
        this.MAX_DURATION_SECONDS = 60 * 60 * 24 * 1000; //1000 days
        this.MIN_DURATION_SECONDS = 60 * 60 * 15; // 15 minutes
        this.start = action_1.Action.create({
            id: "approve",
            run: function (request) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                var makeAssetType, _a, _b, _c;
                return (0, tslib_1.__generator)(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            if (!this.ethereum) {
                                throw new Error("Wallet is undefined");
                            }
                            return [4 /*yield*/, this.checkAssetType(request.makeAssetType)];
                        case 1:
                            makeAssetType = _d.sent();
                            this.validate(request, makeAssetType);
                            _a = wait_tx_1.waitTx;
                            _b = this.approve;
                            _c = types_1.toAddress;
                            return [4 /*yield*/, this.ethereum.getFrom()];
                        case 2: return [4 /*yield*/, _a.apply(void 0, [_b.apply(this, [_c.apply(void 0, [_d.sent()]),
                                    {
                                        assetType: makeAssetType,
                                        value: request.amount,
                                    },
                                    true])])];
                        case 3:
                            _d.sent();
                            return [2 /*return*/, { request: request, makeAssetType: makeAssetType }];
                    }
                });
            }); },
        })
            .thenStep({
            id: "sign",
            run: function (_a) {
                var request = _a.request, makeAssetType = _a.makeAssetType;
                return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                    var sellAsset, buyAssetType, data, _b, _c, _d, tx, _e, _f, _g, _h, auctionIdPromise, hashPromise;
                    var _j;
                    var _this = this;
                    return (0, tslib_1.__generator)(this, function (_k) {
                        switch (_k.label) {
                            case 0:
                                if (!this.ethereum) {
                                    throw new Error("Wallet is undefined");
                                }
                                sellAsset = {
                                    assetType: {
                                        assetClass: (0, id_1.id)(makeAssetType.assetClass),
                                        data: (0, common_1.getAssetEncodedData)(this.ethereum, makeAssetType),
                                    },
                                    value: request.amount,
                                };
                                buyAssetType = {
                                    assetClass: (0, id_1.id)(request.takeAssetType.assetClass),
                                    data: (0, common_1.getAssetEncodedData)(this.ethereum, request.takeAssetType),
                                };
                                _c = (_b = this.ethereum).encodeParameter;
                                _d = [common_1.AUCTION_DATA_V1];
                                _j = {
                                    payouts: [],
                                    originFees: request.originFees || [],
                                    duration: request.duration,
                                    startTime: request.startTime || 0
                                };
                                return [4 /*yield*/, (0, get_price_1.getPrice)(this.ethereum, request.takeAssetType, request.buyOutPriceDecimal)];
                            case 1:
                                data = _c.apply(_b, _d.concat([(_j.buyOutPrice = (_k.sent()).toString(),
                                        _j)]));
                                _e = this.send;
                                _g = (_f = (0, auction_1.createEthereumAuctionContract)(this.ethereum, this.config.auction))
                                    .functionCall;
                                _h = ["startAuction",
                                    sellAsset,
                                    buyAssetType];
                                return [4 /*yield*/, (0, get_price_1.getPrice)(this.ethereum, request.takeAssetType, request.minimalStepDecimal)];
                            case 2:
                                _h = _h.concat([(_k.sent()).toString()]);
                                return [4 /*yield*/, (0, get_price_1.getPrice)(this.ethereum, request.takeAssetType, request.minimalPriceDecimal)];
                            case 3: return [4 /*yield*/, _g.apply(_f, _h.concat([(_k.sent()).toString(),
                                    common_1.AUCTION_DATA_TYPE,
                                    data]))];
                            case 4: return [4 /*yield*/, _e.apply(this, [_k.sent()])];
                            case 5:
                                tx = _k.sent();
                                auctionIdPromise = tx.wait()
                                    .then(function (receipt) {
                                    var createdEvent = receipt.events.find(function (e) { return e.event === "AuctionCreated"; });
                                    if (!createdEvent)
                                        throw new Error("AuctionCreated event has not been found");
                                    return (0, types_1.toBigNumber)(createdEvent.args.auctionId);
                                });
                                hashPromise = auctionIdPromise
                                    .then(function (auctionId) {
                                    return _this.getAuctionHash(auctionId);
                                });
                                return [2 /*return*/, {
                                        tx: tx,
                                        hash: hashPromise,
                                        auctionId: auctionIdPromise,
                                    }];
                        }
                    });
                });
            },
        })
            .before(function (request) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, check_chain_id_1.checkChainId)(this.ethereum, this.config)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, request];
                }
            });
        }); });
        this.checkAssetType = check_asset_type_1.checkAssetType.bind(null, apis.nftCollection);
        this.getAuctionHash = common_1.getAuctionHash.bind(null, this.ethereum, this.config);
    }
    StartAuction.prototype.validate = function (request, makeAssetType) {
        if (!(0, is_nft_1.isNft)(makeAssetType)) {
            throw new Error("Make asset should be NFT token");
        }
        if (makeAssetType.assetClass === "ERC721_LAZY" || makeAssetType.assetClass === "ERC1155_LAZY") {
            throw new Error("Auction cannot be created with lazy assets");
        }
        if (!(0, is_payment_token_1.isPaymentToken)(request.takeAssetType)) {
            throw new Error("Take asset should be payment token (ETH or ERC-20)");
        }
        var minPrice = (0, utils_1.toBn)(request.minimalPriceDecimal);
        if (!minPrice.isPositive()) {
            throw new Error("Minimal price should be a correct value");
        }
        var step = (0, utils_1.toBn)(request.minimalStepDecimal);
        if (!step.isPositive()) {
            throw new Error("Minimal step should be a correct value");
        }
        var startTimestamp = (0, utils_1.toBn)(request.startTime || 0);
        if (!startTimestamp.isZero()) {
            if (startTimestamp.isNaN() || !startTimestamp.isInteger() || startTimestamp.isNegative()) {
                throw new Error("Wrong auction start time timestamp = ".concat(startTimestamp.toString()));
            }
            if (startTimestamp.isLessThan(Date.now() / 1000)) {
                throw new Error("Auction start time should be greater than current time");
            }
        }
        var duration = (0, utils_1.toBn)(request.duration);
        if (duration.isNaN() || duration.isNegative() || duration.isGreaterThan(this.MAX_DURATION_SECONDS)) {
            throw new Error("Incorrect duration value");
        }
        if (this.env !== "e2e" && duration.isLessThan(this.MIN_DURATION_SECONDS)) {
            throw new Error("Auction duration should be greater than minimal duration time");
        }
        var buyout = (0, utils_1.toBn)(request.buyOutPriceDecimal);
        if (!buyout.isPositive() || buyout.isLessThanOrEqualTo(minPrice)) {
            throw new Error("Auction buyout price should be correct and greater than minimal price");
        }
        var amount = (0, utils_1.toBn)(request.amount);
        if (!amount.isInteger() || amount.isLessThanOrEqualTo(0)) {
            throw new Error("Auction asset amount should be integer and greater than 0");
        }
        (0, validate_part_1.validateParts)(request.originFees);
        return true;
    };
    return StartAuction;
}());
exports.StartAuction = StartAuction;
