"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuyoutAuction = void 0;
var tslib_1 = require("tslib");
var types_1 = require("@rarible/types");
var action_1 = require("@rarible/action");
var wait_tx_1 = require("../common/wait-tx");
var get_price_1 = require("../common/get-price");
var check_chain_id_1 = require("../order/check-chain-id");
var get_base_fee_1 = require("../common/get-base-fee");
var auction_1 = require("./contracts/auction");
var common_1 = require("./common");
var BuyoutAuction = /** @class */ (function () {
    function BuyoutAuction(ethereum, send, config, env, approve, apis) {
        var _this = this;
        this.ethereum = ethereum;
        this.send = send;
        this.config = config;
        this.env = env;
        this.approve = approve;
        this.apis = apis;
        this.buyout = action_1.Action.create({
            id: "approve",
            run: function (request) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                var auction, buyoutPrice, _a, _b, _c, _d;
                return (0, tslib_1.__generator)(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            if (!this.ethereum) {
                                throw new Error("Wallet is undefined");
                            }
                            return [4 /*yield*/, this.apis.auction.getAuctionByHash({ hash: request.hash })];
                        case 1:
                            auction = _e.sent();
                            this.validate(auction);
                            if (auction.data.buyOutPrice === undefined) {
                                throw new Error("Buy out is unavailable for current auction");
                            }
                            _a = types_1.toBigNumber;
                            return [4 /*yield*/, (0, get_price_1.getPrice)(this.ethereum, auction.buy, auction.data.buyOutPrice)];
                        case 2:
                            buyoutPrice = _a.apply(void 0, [(_e.sent()).toString()]);
                            if (!(auction.buy.assetClass !== "ETH")) return [3 /*break*/, 5];
                            _b = wait_tx_1.waitTx;
                            _c = this.approve;
                            _d = types_1.toAddress;
                            return [4 /*yield*/, this.ethereum.getFrom()];
                        case 3: return [4 /*yield*/, _b.apply(void 0, [_c.apply(this, [_d.apply(void 0, [_e.sent()]),
                                    { assetType: auction.buy, value: buyoutPrice },
                                    true])])];
                        case 4:
                            _e.sent();
                            _e.label = 5;
                        case 5: return [2 /*return*/, { request: request, auction: auction, price: buyoutPrice }];
                    }
                });
            }); },
        })
            .thenStep({
            id: "sign",
            run: function (_a) {
                var request = _a.request, auction = _a.auction, price = _a.price;
                return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                    var buyerOriginFees, bidData, bid, protocolFee, totalFees, options, contract;
                    return (0, tslib_1.__generator)(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                if (!this.ethereum) {
                                    throw new Error("Wallet is undefined");
                                }
                                buyerOriginFees = request.originFees || [];
                                bidData = this.ethereum.encodeParameter(common_1.AUCTION_BID_DATA_V1, {
                                    payouts: [],
                                    originFees: buyerOriginFees,
                                });
                                bid = {
                                    amount: price,
                                    dataType: common_1.AUCTION_DATA_TYPE,
                                    data: bidData,
                                };
                                return [4 /*yield*/, this.getBaseFee()];
                            case 1:
                                protocolFee = _b.sent();
                                totalFees = (0, common_1.calculatePartsSum)(buyerOriginFees.concat(auction.data.originFees)) + protocolFee;
                                options = (0, common_1.getAuctionOperationOptions)(auction.buy, price, totalFees);
                                contract = (0, auction_1.createEthereumAuctionContract)(this.ethereum, this.config.auction);
                                return [2 /*return*/, this.send(contract.functionCall("buyOut", auction.auctionId, bid), options)];
                        }
                    });
                });
            },
        })
            .before(function (request) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, (0, check_chain_id_1.checkChainId)(this.ethereum, this.config)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, request];
                }
            });
        }); });
        this.getBaseFee = get_base_fee_1.getBaseFee.bind(null, config, env, "AUCTION");
    }
    BuyoutAuction.prototype.validate = function (auction) {
        if (!(0, common_1.validateAuctionRangeTime)(auction)) {
            throw new Error("Auction should be active");
        }
    };
    return BuyoutAuction;
}());
exports.BuyoutAuction = BuyoutAuction;
