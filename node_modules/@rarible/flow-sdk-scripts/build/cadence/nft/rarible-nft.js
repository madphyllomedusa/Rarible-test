"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RaribleNFT = void 0;
exports.RaribleNFT = {
    get_ids: "\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport RaribleNFT from 0xRARIBLENFT\n\n// Take RaribleNFT ids by account address\n//\npub fun main(address: Address): [UInt64]? {\n    let collection = getAccount(address)\n        .getCapability(RaribleNFT.collectionPublicPath)\n        .borrow<&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}>()\n        ?? panic(\"NFT Collection not found\")\n    return collection.getIDs()\n}\n",
    borrow_nft: "\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport RaribleNFT from 0xRARIBLENFT\n\n// Take RaribleNFT token props by account address and tokenId\n//\npub fun main(address: Address, tokenId: UInt64): &AnyResource {\n    let collection = getAccount(address)\n        .getCapability(RaribleNFT.collectionPublicPath)\n        .borrow<&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}>()\n        ?? panic(\"NFT Collection not found\")\n    return collection.borrowNFT(id: tokenId)\n}\n",
    check: "\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\n    import RaribleNFT from 0xRARIBLENFT\n\n    // check RaribleNFT collection is available on given address\n    //\n    pub fun main(address: Address): Bool {\n        return getAccount(address)\n            .getCapability<&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}>(RaribleNFT.collectionPublicPath)\n            .check()\n    }\n",
    setup_account: "\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport RaribleNFT from 0xRARIBLENFT\n\n// Setup storage for RaribleNFT on signer account\n//\ntransaction {\n    prepare(acct: AuthAccount) {\n        if acct.borrow<&RaribleNFT.Collection>(from: RaribleNFT.collectionStoragePath) == nil {\n            let collection <- RaribleNFT.createEmptyCollection() as! @RaribleNFT.Collection\n            acct.save(<-collection, to: RaribleNFT.collectionStoragePath)\n            acct.link<&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}>(RaribleNFT.collectionPublicPath, target: RaribleNFT.collectionStoragePath)\n        }\n    }\n}\n",
    transfer: "\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport RaribleNFT from 0xRARIBLENFT\n\n// transfer RaribleNFT token with tokenId to given address\n//\ntransaction(tokenId: UInt64, to: Address) {\n    let token: @NonFungibleToken.NFT\n    let receiver: Capability<&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}>\n\n    prepare(acct: AuthAccount) {\n        let collection = acct.borrow<&RaribleNFT.Collection>(from: RaribleNFT.collectionStoragePath)\n            ?? panic(\"Missing NFT collection on signer account\")\n        self.token <- collection.withdraw(withdrawID: tokenId)\n        self.receiver = getAccount(to).getCapability<&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}>(RaribleNFT.collectionPublicPath)\n    }\n\n    execute {\n        let receiver = self.receiver.borrow()!\n        receiver.deposit(token: <- self.token)\n    }\n}\n",
    burn: "\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport RaribleNFT from 0xRARIBLENFT\n\n// Burn RaribleNFT on signer account by tokenId\n//\ntransaction(tokenId: UInt64) {\n    prepare(account: AuthAccount) {\n        let collection = account.borrow<&RaribleNFT.Collection>(from: RaribleNFT.collectionStoragePath)!\n        destroy collection.withdraw(withdrawID: tokenId)\n    }\n}\n",
    mint: "\nimport NonFungibleToken from 0xNONFUNGIBLETOKEN\nimport RaribleNFT from 0xRARIBLENFT\n\n// Mint RaribleNFT token to signer acct\n//\ntransaction(metadata: String, royalties: [RaribleNFT.Royalty]) {\n    let minter: Capability<&RaribleNFT.Minter>\n    let receiver: Capability<&{NonFungibleToken.Receiver}>\n\n    prepare(acct: AuthAccount) {\n        if acct.borrow<&RaribleNFT.Collection>(from: RaribleNFT.collectionStoragePath) == nil {\n            let collection <- RaribleNFT.createEmptyCollection() as! @RaribleNFT.Collection\n            acct.save(<- collection, to: RaribleNFT.collectionStoragePath)\n            acct.link<&{NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver}>(RaribleNFT.collectionPublicPath, target: RaribleNFT.collectionStoragePath)\n        }\n\n        self.minter = RaribleNFT.minter()\n        self.receiver = acct.getCapability<&{NonFungibleToken.Receiver}>(RaribleNFT.collectionPublicPath)\n    }\n\n    execute {\n        let minter = self.minter.borrow() ?? panic(\"Could not borrow receiver capability (maybe receiver not configured?)\")\n        minter.mintTo(creator: self.receiver, metadata: {\"metaURI\": metadata}, royalties: royalties)\n    }\n}\n",
};
