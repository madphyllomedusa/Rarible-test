"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.openBidTransactionCode = void 0;
exports.openBidTransactionCode = {
    openBid: "\n\t\timport FungibleToken from address\nimport NonFungibleToken from address\nimport RaribleOpenBid from address\nimport %ftContract% from address\nimport %nftContract% from address\n\ntransaction(nftId: UInt64, price: UFix64, parts: {Address:UFix64}) {\n    let openBid: &RaribleOpenBid.OpenBid\n    let nftReceiver: Capability<&{NonFungibleToken.CollectionPublic}>\n    let vaultRef: Capability<&{%ftPrivateType%}>\n\n    prepare(account: AuthAccount) {\n        if !account.getCapability<&{%nftPublicType%}>(%nftPublicPath%).check() {\n            if account.borrow<&AnyResource>(from: %nftStoragePath%) != nil {\n                account.unlink(%nftPublicPath%)\n                account.link<&{%nftPublicType%}>(%nftPublicPath%, target: %nftStoragePath%)\n            } else {\n                let collection <- %nftContract%.createEmptyCollection() as! @%nftStorageType%\n                account.save(<-collection, to: %nftStoragePath%)\n                account.link<&{%nftPublicType%}>(%nftPublicPath%, target: %nftStoragePath%)\n            }\n        }\n\n        self.nftReceiver = account.getCapability<&{NonFungibleToken.CollectionPublic}>(%nftPublicPath%)\n        assert(self.nftReceiver.check(), message: \"Missing or mis-typed %nftContract% receiver\")\n\n        if !account.getCapability<&{%ftPrivateType%}>(%ftPrivatePath%)!.check() {\n            account.link<&{%ftPrivateType%}>(%ftPrivatePath%, target: %ftStoragePath%)\n        }\n\n        self.vaultRef = account.getCapability<&{%ftPrivateType%}>(%ftPrivatePath%)!\n        assert(self.vaultRef.check(), message: \"Missing or mis-typed fungible token vault ref\")\n\n        if account.borrow<&RaribleOpenBid.OpenBid>(from: RaribleOpenBid.OpenBidStoragePath) == nil {\n            let openBid <- RaribleOpenBid.createOpenBid()\n            account.save(<-openBid, to: RaribleOpenBid.OpenBidStoragePath)\n            account.link<&RaribleOpenBid.OpenBid{RaribleOpenBid.OpenBidPublic}>(RaribleOpenBid.OpenBidPublicPath, target: RaribleOpenBid.OpenBidStoragePath)\n        }\n\n        self.openBid = account.borrow<&RaribleOpenBid.OpenBid>(from: RaribleOpenBid.OpenBidStoragePath)\n            ?? panic(\"Missing or mis-typed RaribleOpenBid OpenBid\")\n    }\n\n    execute {\n        var amount = price\n        let cuts: [RaribleOpenBid.Cut] = []\n        for address in parts.keys {\n            amount = amount + parts[address]!\n            cuts.append(\n                RaribleOpenBid.Cut(\n                    receiver: getAccount(address).getCapability<&{FungibleToken.Receiver}>(%ftPublicPath%),\n                    amount: parts[address]!,\n                )\n            )\n        }\n\n        self.openBid.createBid(\n            vaultRefCapability: self.vaultRef,\n            offerPrice: amount,\n            rewardCapability: self.nftReceiver,\n            nftType: Type<@%nftContract%.NFT>(),\n            nftId: nftId,\n            cuts: cuts,\n        )\n    }\n}\n\n\t\t",
    closeBid: "\n\timport FungibleToken from address\nimport NonFungibleToken from address\nimport RaribleOpenBid from address\nimport %ftContract% from address\nimport %nftContract% from address\n\ntransaction(bidId: UInt64, openBidAddress: Address, parts: {Address:UFix64}) {\n    let openBid: &RaribleOpenBid.OpenBid{RaribleOpenBid.OpenBidPublic}\n    let bid: &RaribleOpenBid.Bid{RaribleOpenBid.BidPublic}\n    let nft: @NonFungibleToken.NFT\n    let mainVault: &{FungibleToken.Receiver}\n\n    prepare(account: AuthAccount) {\n        self.openBid = getAccount(openBidAddress)\n            .getCapability(RaribleOpenBid.OpenBidPublicPath)!\n            .borrow<&RaribleOpenBid.OpenBid{RaribleOpenBid.OpenBidPublic}>()\n            ?? panic(\"Could not borrow OpenBid from provided address\")\n\n        self.bid = self.openBid.borrowBid(bidId: bidId)\n            ?? panic(\"No Offer with that ID in OpenBid\")\n\n        let nftId = self.bid.getDetails().nftId\n        let nftCollection = account.borrow<&%nftStorageType%>(from: %nftStoragePath%)\n            ?? panic(\"Cannot borrow NFT collection receiver from account\")\n        self.nft <- nftCollection.withdraw(withdrawID: nftId)\n\n        self.mainVault = account.borrow<&{FungibleToken.Receiver}>(from: %ftStoragePath%)\n            ?? panic(\"Cannot borrow FlowToken vault from account storage\")\n    }\n\n    execute {\n        let vault <- self.bid.purchase(item: <-self.nft)!\n        for address in parts.keys {\n            let receiver = getAccount(address).getCapability(%ftPublicPath%).borrow<&{FungibleToken.Receiver}>()!\n            let part <- vault.withdraw(amount: parts[address]!)\n            receiver.deposit(from: <- part)\n        }\n        self.mainVault.deposit(from: <-vault)\n        self.openBid.cleanup(bidId: bidId)\n    }\n}\n",
    cancelBid: "\n\t\timport RaribleOpenBid from adress\n\ntransaction(bidId: UInt64) {\n    let openBid: &RaribleOpenBid.OpenBid{RaribleOpenBid.OpenBidManager}\n\n    prepare(acct: AuthAccount) {\n        self.openBid = acct.borrow<&RaribleOpenBid.OpenBid{RaribleOpenBid.OpenBidManager}>(from: RaribleOpenBid.OpenBidStoragePath)\n            ?? panic(\"Missing or mis-typed RaribleOpenBid.OpenBid\")\n    }\n\n    execute {\n        self.openBid.removeBid(bidId: bidId)\n    }\n}",
    updateBid: "\n\t\timport FungibleToken from address\nimport NonFungibleToken from address\nimport RaribleOpenBid from address\nimport %ftContract% from address\nimport %nftContract% from address\n\ntransaction(bidId: UInt64, price: UFix64, parts: {Address:UFix64}) {\n    let openBid: &RaribleOpenBid.OpenBid\n    let bid: &RaribleOpenBid.Bid{RaribleOpenBid.BidPublic}\n    let nftReceiver: Capability<&{NonFungibleToken.CollectionPublic}>\n    let vaultRef: Capability<&{%ftPrivateType%}>\n\n    prepare(account: AuthAccount) {\n        self.openBid = account.borrow<&RaribleOpenBid.OpenBid>(from: RaribleOpenBid.OpenBidStoragePath)\n            ?? panic(\"Missing or mis-typed RaribleOpenBid OpenBid\")\n\n        self.bid = self.openBid.borrowBid(bidId: bidId)!\n\n        if !account.getCapability<&{%nftPublicType%}>(%nftPublicPath%).check() {\n            if account.borrow<&AnyResource>(from: %nftStoragePath%) != nil {\n                account.unlink(%nftPublicPath%)\n                account.link<&{%nftPublicType%}>(%nftPublicPath%, target: %nftStoragePath%)\n            } else {\n                let collection <- %nftContract%.createEmptyCollection() as! @%nftStorageType%\n                account.save(<-collection, to: %nftStoragePath%)\n                account.link<&{%nftPublicType%}>(%nftPublicPath%, target: %nftStoragePath%)\n            }\n        }\n\n        self.nftReceiver = account.getCapability<&{NonFungibleToken.CollectionPublic}>(%nftPublicPath%)\n        assert(self.nftReceiver.check(), message: \"Missing or mis-typed %nftContract% receiver\")\n\n        if !account.getCapability<&{%ftPrivateType%}>(%ftPrivatePath%)!.check() {\n            account.link<&{%ftPrivateType%}>(%ftPrivatePath%, target: %ftStoragePath%)\n        }\n\n        self.vaultRef = account.getCapability<&{%ftPrivateType%}>(%ftPrivatePath%)!\n        assert(self.vaultRef.check(), message: \"Missing or mis-typed fungible token vault ref\")\n    }\n\n    execute {\n        let details = self.bid.getDetails()\n        self.openBid.removeBid(bidId: bidId)\n\n        var amount = price\n        let cuts: [RaribleOpenBid.Cut] = []\n        for address in parts.keys {\n            amount = amount + parts[address]!\n            cuts.append(\n                RaribleOpenBid.Cut(\n                    receiver: getAccount(address).getCapability<&{FungibleToken.Receiver}>(%ftPublicPath%),\n                    amount: parts[address]!,\n                )\n            )\n        }\n\n        self.openBid.createBid(\n            vaultRefCapability: self.vaultRef,\n            offerPrice: amount,\n            rewardCapability: self.nftReceiver,\n            nftType: details.nftType,\n            nftId: details.nftId,\n            cuts: cuts,\n        )\n    }\n}\n\t\t",
};
