"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorefrontCommon = void 0;
exports.StorefrontCommon = {
    read_listing_details: "\nimport NFTStorefront from 0xNFTSTOREFRONT\n\n// This script returns the details for a listing within a storefront\n\npub fun main(address: Address, listingResourceID: UInt64): NFTStorefront.ListingDetails {\n    let storefrontRef = getAccount(address)\n        .getCapability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(\n            NFTStorefront.StorefrontPublicPath\n        )\n        .borrow()\n        ?? panic(\"Could not borrow public storefront from address\")\n\n    let listing = storefrontRef.borrowListing(listingResourceID: listingResourceID)\n        ?? panic(\"No item with that ID\")\n\n    return listing.getDetails()\n}\n",
    read_storefront_ids: "\nimport NFTStorefront from 0xNFTSTOREFRONT\n\n// This script returns an array of all the nft uuids for sale through a Storefront\n\npub fun main(address: Address): [UInt64] {\n    let storefrontRef = getAccount(address)\n        .getCapability<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(\n            NFTStorefront.StorefrontPublicPath\n        )\n        .borrow()\n        ?? panic(\"Could not borrow public storefront from address\")\n\n    return storefrontRef.getListingIDs()\n}\n",
    remove_item: "\nimport RaribleOrder from 0xCOMMONORDER\nimport NFTStorefront from 0xNFTSTOREFRONT\n\ntransaction (orderId: UInt64) {\n    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}\n    let storefront: &NFTStorefront.Storefront\n    let orderAddress: Address\n\n    prepare(acct: AuthAccount) {\n        self.storefront = acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Missing or mis-typed NFTStorefront Storefront\")\n\n        self.listing = self.storefront.borrowListing(listingResourceID: orderId)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n\n        self.orderAddress = acct.address\n    }\n\n    execute {\n        RaribleOrder.removeOrder(\n            storefront: self.storefront,\n            orderId: orderId,\n            orderAddress: self.orderAddress,\n            listing: self.listing,\n        )\n    }\n}\n",
    setup_account: "\nimport NFTStorefront from 0xNFTSTOREFRONT\n\n// This transaction installs the Storefront ressource in an account.\n\ntransaction {\n    prepare(acct: AuthAccount) {\n\n        // If the account doesn't already have a Storefront\n        if acct.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) == nil {\n\n            // Create a new empty .Storefront\n            let storefront <- NFTStorefront.createStorefront() as! @NFTStorefront.Storefront\n\n            // save it to the account\n            acct.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)\n\n            // create a public capability for the .Storefront\n            acct.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n    }\n}\n",
};
