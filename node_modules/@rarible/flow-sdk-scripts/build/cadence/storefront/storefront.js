"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Storefront = void 0;
exports.Storefront = {
    createSellOrder: "\n\timport FungibleToken from address\nimport NonFungibleToken from address\nimport NFTStorefront from address\nimport %ftContract% from address\nimport %nftContract% from address\n\n// List %nftContract% item\n//\n//   tokenId - %nftContract% item id for sale\n//   parts - all payments after complete order {address:amount}\n//\ntransaction(tokenId: UInt64, parts: {Address: UFix64}) {\n    let storefront: &NFTStorefront.Storefront\n    let nftProvider: Capability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic}>\n\n    prepare(account: AuthAccount) {\n        if !account.getCapability<&{%nftPrivateType%}>(%nftPrivatePath%)!.check() {\n            account.link<&{%nftPrivateType%}>(%nftPrivatePath%, target: %nftStoragePath%)\n        }\n        self.nftProvider = account.getCapability<&{%nftPrivateType%}>(%nftPrivatePath%)\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nft collection provider\")\n\n        if let storefront = account.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) {\n            self.storefront = storefront\n        } else {\n            let storefront <- NFTStorefront.createStorefront()\n            self.storefront = &storefront as &NFTStorefront.Storefront\n            account.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)\n            account.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n    }\n\n    execute {\n        let cuts: [NFTStorefront.SaleCut] = []\n        for address in parts.keys {\n            let receiver = getAccount(address).getCapability<&{FungibleToken.Receiver}>(%ftPublicPath%)\n            assert(receiver.check(), message: \"Missing or mis-typed fungible token receiver\")\n            let cut = NFTStorefront.SaleCut(receiver: receiver, amount: parts[address]!)\n            cuts.append(cut)\n        }\n\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: Type<@%nftContract%.NFT>(),\n            nftID: tokenId,\n            salePaymentVaultType: Type<@%ftContract%.Vault>(),\n            saleCuts: cuts\n        )\n    }\n}\n\t",
    buy: "\n\timport FungibleToken from address\nimport NonFungibleToken from address\nimport NFTStorefront from address\nimport %ftContract% from address\nimport %nftContract% from address\n\n// Buy %nftContract% item\n//\n//   orderId - NFTStorefront listingResourceID\n//   storefrontAddress - seller address\n//   parts - buyer payments {address:amount}\n//\ntransaction(orderId: UInt64, storefrontAddress: Address, parts: {Address:UFix64}) {\n    let storefront: &NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}\n    let listing: &NFTStorefront.Listing{NFTStorefront.ListingPublic}\n    let paymentVault: @FungibleToken.Vault\n    let nftCollection: &{NonFungibleToken.Receiver}\n\n    prepare(account: AuthAccount) {\n        self.storefront = getAccount(storefrontAddress)\n            .getCapability(NFTStorefront.StorefrontPublicPath)\n            .borrow<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>()\n            ?? panic(\"Could not borrow Storefront from provided address\")\n\n        self.listing = self.storefront.borrowListing(listingResourceID: orderId)\n                    ?? panic(\"No Offer with that ID in Storefront\")\n        var amount = self.listing.getDetails().salePrice\n        for address in parts.keys {\n            amount = amount + parts[address]!\n        }\n\n        let mainVault = account.borrow<&FungibleToken.Vault>(from: %ftStoragePath%)\n            ?? panic(\"Cannot borrow %ftContract% vault from account storage\")\n        self.paymentVault <- mainVault.withdraw(amount: amount)\n\n        if !account.getCapability<&{%nftPublicType%}>(%nftPublicPath%).check() {\n            if account.borrow<&AnyResource>(from: %nftStoragePath%) != nil {\n                account.unlink(%nftPublicPath%)\n                account.link<&{%nftPublicType%}>(%nftPublicPath%, target: %nftStoragePath%)\n            } else {\n                let collection <- %nftContract%.createEmptyCollection() as! @%nftStorageType%\n                account.save(<-collection, to: %nftStoragePath%)\n                account.link<&{%nftPublicType%}>(%nftPublicPath%, target: %nftStoragePath%)\n            }\n        }\n        self.nftCollection = account.borrow<&{NonFungibleToken.Receiver}>(from: %nftStoragePath%)\n            ?? panic(\"Cannot borrow NFT collection receiver from account\")\n    }\n\n    execute {\n        for address in parts.keys {\n            let receiver = getAccount(address).getCapability<&{FungibleToken.Receiver}>(%ftPublicPath%)\n            assert(receiver.check(), message: \"Cannot borrow %ftContract% receiver\")\n            let part <- self.paymentVault.withdraw(amount: parts[address]!)\n            receiver.borrow()!.deposit(from: <- part)\n        }\n\n        let item <- self.listing.purchase(payment: <-self.paymentVault)\n        self.nftCollection.deposit(token: <-item)\n        self.storefront.cleanup(listingResourceID: orderId)\n    }\n}\n\n\t",
    cancelOrder: "\nimport NFTStorefront from address\n\ntransaction(orderId: UInt64) {\n\n    let storefront: &NFTStorefront.Storefront\n\n    prepare(account: AuthAccount) {\n        self.storefront = account.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath)\n            ?? panic(\"Could not borrow Storefront from account\")\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: orderId)\n    }\n}\n\t\t",
    updateOrder: "\n\timport FungibleToken from address\nimport NonFungibleToken from address\nimport NFTStorefront from address\nimport %ftContract% from address\nimport %nftContract% from address\n\n// Relist %nftContract% item\n//\n//   orderId - replacing NFTStorefront listingResourceID\n//   parts - all payments after complete order {address:amount}\n//\ntransaction(orderId: UInt64, parts: {Address: UFix64}) {\n    let storefront: &NFTStorefront.Storefront\n    let details: NFTStorefront.ListingDetails\n    let nftProvider: Capability<&{NonFungibleToken.Provider,NonFungibleToken.CollectionPublic}>\n\n    prepare(account: AuthAccount) {\n        if !account.getCapability<&{%nftPrivateType%}>(%nftPrivatePath%)!.check() {\n            account.link<&{%nftPrivateType%}>(%nftPrivatePath%, target: %nftStoragePath%)\n        }\n        self.nftProvider = account.getCapability<&{%nftPrivateType%}>(%nftPrivatePath%)\n        assert(self.nftProvider.borrow() != nil, message: \"Missing or mis-typed nft collection provider\")\n\n        if let storefront = account.borrow<&NFTStorefront.Storefront>(from: NFTStorefront.StorefrontStoragePath) {\n            self.storefront = storefront\n        } else {\n            let storefront <- NFTStorefront.createStorefront()\n            self.storefront = &storefront as &NFTStorefront.Storefront\n            account.save(<-storefront, to: NFTStorefront.StorefrontStoragePath)\n            account.link<&NFTStorefront.Storefront{NFTStorefront.StorefrontPublic}>(NFTStorefront.StorefrontPublicPath, target: NFTStorefront.StorefrontStoragePath)\n        }\n\n        let listing = self.storefront.borrowListing(listingResourceID: orderId)\n            ?? panic(\"No Offer with that ID in Storefront\")\n        self.details = listing.getDetails()\n    }\n\n    execute {\n        self.storefront.removeListing(listingResourceID: orderId)\n\n        let cuts: [NFTStorefront.SaleCut] = []\n        for address in parts.keys {\n            let receiver = getAccount(address).getCapability<&{FungibleToken.Receiver}>(%ftPublicPath%)\n            assert(receiver.check(), message: \"Missing or mis-typed fungible token receiver\")\n            let cut = NFTStorefront.SaleCut(receiver: receiver, amount: parts[address]!)\n            cuts.append(cut)\n        }\n\n        self.storefront.createListing(\n            nftProviderCapability: self.nftProvider,\n            nftType: self.details.nftType,\n            nftID: self.details.nftID,\n            salePaymentVaultType: Type<@%ftContract%.Vault>(),\n            saleCuts: cuts\n        )\n    }\n}\n\n\t",
};
