"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertTezosToUnionAddress = exports.convertTezosToCollectionAddress = exports.convertTezosToContractAddress = exports.convertTezosItemId = exports.convertTezosOrderId = exports.convertUnionAddress = exports.convertFromContractAddress = exports.convertOrderPayout = exports.convertTezosToUnionAsset = exports.covertToLibAsset = exports.getTezosAssetType = exports.convertOrderToOrderForm = exports.convertOrderToFillOrder = exports.getSupportedCurrencies = exports.getPayouts = exports.getMakerPublicKey = exports.getTezosAddress = exports.getTezosItemData = exports.getTezosOrderId = exports.getRequiredProvider = exports.getMaybeTezosProvider = exports.isExistedTezosProvider = exports.getTezosBasePath = exports.getTezosAPIs = exports.XTZ_DECIMALS = void 0;
var tslib_1 = require("tslib");
var api_client_1 = require("@rarible/api-client");
// eslint-disable-next-line camelcase
var tezos_sdk_1 = require("@rarible/tezos-sdk");
var bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
var build_1 = require("tezos-api-client/build");
var big_number_1 = require("@rarible/types/build/big-number");
var types_1 = require("@rarible/types");
exports.XTZ_DECIMALS = 6;
function getTezosAPIs(network) {
    var config = new build_1.Configuration({
        basePath: getTezosBasePath(network),
    });
    return {
        collection: new build_1.NftCollectionControllerApi(config),
        item: new build_1.NftItemControllerApi(config),
        ownership: new build_1.NftOwnershipControllerApi(config),
        order: new build_1.OrderControllerApi(config),
    };
}
exports.getTezosAPIs = getTezosAPIs;
function getTezosBasePath(network) {
    switch (network) {
        case "hangzhou": {
            return "https://test-tezos-api.rarible.org";
        }
        case "dev": {
            return "https://dev-tezos-api.rarible.org";
        }
        case "mainnet": {
            return "https://tezos-api.rarible.org";
        }
        default: {
            throw new Error("Unsupported tezos network");
        }
    }
}
exports.getTezosBasePath = getTezosBasePath;
function isExistedTezosProvider(provider) {
    return provider.tezos !== undefined;
}
exports.isExistedTezosProvider = isExistedTezosProvider;
function getMaybeTezosProvider(provider, network) {
    switch (network) {
        case "hangzhou": {
            return {
                tezos: provider,
                config: {
                    exchange: "KT1S6H2FWxrpaD7aPRSW1cTTE1xPucXBSTL5",
                    transfer_proxy: "KT1WbVjXdmBpzzVoYSSUiNt6QFnSC3W768d1",
                    fees: new bignumber_js_1.default(0),
                    nft_public: "",
                    mt_public: "",
                    api: "".concat(getTezosBasePath(network), "/v0.1"),
                    api_permit: "".concat(getTezosBasePath(network), "/v0.1"),
                    permit_whitelist: [],
                    wrapper: "",
                    auction: "",
                    auction_storage: "",
                    node_url: "https://test-tezos-node.rarible.org",
                },
            };
        }
        case "dev": {
            return {
                tezos: provider,
                config: {
                    exchange: "KT1KDFn2Rfg597Rq14xrD2gtEEy2PP4F6kag",
                    transfer_proxy: "KT1PZGQqjcL3ww2zNyvbZY4SwBDNumTr6bmz",
                    fees: new bignumber_js_1.default(0),
                    nft_public: "",
                    mt_public: "",
                    api: "".concat(getTezosBasePath(network), "/v0.1"),
                    api_permit: "".concat(getTezosBasePath(network), "/v0.1"),
                    permit_whitelist: [],
                    wrapper: "",
                    auction: "",
                    auction_storage: "",
                    node_url: "https://dev-tezos-node.rarible.org",
                },
            };
        }
        case "mainnet": {
            return {
                tezos: provider,
                config: {
                    exchange: "KT198mqFKkiWerXLmMCw69YB1i6yzYtmGVrC",
                    transfer_proxy: "KT1N2oby9tYmv5tjkGD1KyVzkDRCmgDkXgSD",
                    fees: new bignumber_js_1.default(0),
                    nft_public: "",
                    mt_public: "",
                    api: "".concat(getTezosBasePath(network), "/v0.1"),
                    api_permit: "".concat(getTezosBasePath(network), "/v0.1"),
                    permit_whitelist: [],
                    wrapper: "KT1EJkjatSNWD2NiPx8hivKnawxuyaVTwP6n",
                    auction: "",
                    auction_storage: "",
                    node_url: "https://mainnet.api.tez.ie",
                },
            };
        }
        default: {
            throw new Error("Unsupported tezos network for config");
        }
    }
}
exports.getMaybeTezosProvider = getMaybeTezosProvider;
function getRequiredProvider(provider) {
    if (!isExistedTezosProvider(provider)) {
        throw new Error("Tezos provider is required");
    }
    return provider;
}
exports.getRequiredProvider = getRequiredProvider;
function getTezosOrderId(orderId) {
    if (!orderId) {
        throw new Error("OrderId has not been specified");
    }
    var _a = tslib_1.__read(orderId.split(":"), 2), blockchain = _a[0], id = _a[1];
    if (blockchain !== api_client_1.Blockchain.TEZOS) {
        throw new Error("Not an TEZOS order");
    }
    return id;
}
exports.getTezosOrderId = getTezosOrderId;
function getTezosItemData(itemId) {
    var _a = tslib_1.__read(itemId.split(":"), 3), domain = _a[0], contract = _a[1], tokenId = _a[2];
    if (domain !== api_client_1.Blockchain.TEZOS) {
        throw new Error("Not an tezos item: ".concat(itemId));
    }
    return {
        itemId: "".concat(contract, ":").concat(tokenId),
        contract: contract,
        tokenId: tokenId,
        domain: domain,
    };
}
exports.getTezosItemData = getTezosItemData;
function getTezosAddress(address) {
    var _a = tslib_1.__read(address.split(":"), 2), blockchain = _a[0], tezosAddress = _a[1];
    if (blockchain !== api_client_1.Blockchain.TEZOS) {
        throw new Error("Not an tezos item: ".concat(address));
    }
    return tezosAddress;
}
exports.getTezosAddress = getTezosAddress;
function getMakerPublicKey(provider) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var maker;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, (0, tezos_sdk_1.get_public_key)(provider)];
                case 1:
                    maker = _a.sent();
                    if (!maker) {
                        throw new Error("Maker does not exist");
                    }
                    return [2 /*return*/, maker];
            }
        });
    });
}
exports.getMakerPublicKey = getMakerPublicKey;
function getPayouts(provider, requestPayouts) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var payouts, _a;
        var _b;
        return tslib_1.__generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    payouts = requestPayouts || [];
                    if (!(!Array.isArray(payouts) || payouts.length === 0)) return [3 /*break*/, 2];
                    _b = {};
                    _a = tezos_sdk_1.pk_to_pkh;
                    return [4 /*yield*/, getMakerPublicKey(provider)];
                case 1: return [2 /*return*/, [(_b.account = _a.apply(void 0, [_c.sent()]),
                            _b.value = new bignumber_js_1.default(10000),
                            _b)]];
                case 2: return [2 /*return*/, convertOrderPayout(payouts)];
            }
        });
    });
}
exports.getPayouts = getPayouts;
function getSupportedCurrencies() {
    return [
        { blockchain: api_client_1.Blockchain.TEZOS, type: "NATIVE" },
        { blockchain: api_client_1.Blockchain.TEZOS, type: "TEZOS_FT" },
    ];
}
exports.getSupportedCurrencies = getSupportedCurrencies;
function convertOrderToFillOrder(order) {
    return tslib_1.__assign(tslib_1.__assign({}, convertOrderToOrderForm(order)), { makeStock: (0, big_number_1.toBigNumber)(order.makeStock) });
}
exports.convertOrderToFillOrder = convertOrderToFillOrder;
function convertOrderToOrderForm(order) {
    if (order.data["@type"] !== "TEZOS_RARIBLE_V2") {
        throw new Error("Unsupported order data type");
    }
    return {
        type: "RARIBLE_V2",
        maker: order.maker,
        maker_edpk: order.data.makerEdpk,
        taker: order.taker,
        taker_edpk: order.data.takerEdpk,
        make: {
            asset_type: getTezosAssetType(order.make.type),
            value: new bignumber_js_1.default(order.make.value),
        },
        take: {
            asset_type: getTezosAssetType(order.take.type),
            value: new bignumber_js_1.default(order.take.value),
        },
        salt: order.salt,
        start: order.startedAt ? parseInt(order.startedAt) : undefined,
        end: order.endedAt ? parseInt(order.endedAt) : undefined,
        signature: order.signature,
        data: {
            data_type: "V1",
            payouts: convertOrderPayout(order.data.payouts),
            origin_fees: convertOrderPayout(order.data.originFees),
        },
    };
}
exports.convertOrderToOrderForm = convertOrderToOrderForm;
function getTezosAssetType(type) {
    switch (type["@type"]) {
        case "XTZ": {
            return {
                asset_class: "XTZ",
            };
        }
        case "TEZOS_FT": {
            return {
                asset_class: "FT",
                contract: convertFromContractAddress(type.contract),
                token_id: type.tokenId ? new bignumber_js_1.default(type.tokenId) : undefined,
            };
        }
        case "TEZOS_NFT": {
            return {
                asset_class: "NFT",
                contract: convertFromContractAddress(type.contract),
                token_id: new bignumber_js_1.default(type.tokenId),
            };
        }
        case "TEZOS_MT": {
            return {
                asset_class: "MT",
                contract: convertFromContractAddress(type.contract),
                token_id: new bignumber_js_1.default(type.tokenId),
            };
        }
        default: {
            throw new Error("Invalid take asset type");
        }
    }
}
exports.getTezosAssetType = getTezosAssetType;
function covertToLibAsset(a) {
    switch (a.assetType.assetClass) {
        case "XTZ": {
            return {
                asset_type: { asset_class: a.assetType.assetClass },
                value: new bignumber_js_1.default(a.value),
            };
        }
        case "FT": {
            return {
                asset_type: {
                    asset_class: a.assetType.assetClass,
                    contract: a.assetType.contract,
                    token_id: (a.assetType.tokenId === undefined) ? undefined : new bignumber_js_1.default(a.assetType.tokenId),
                },
                value: new bignumber_js_1.default(a.value),
            };
        }
        case "NFT":
        case "MT":
            return {
                asset_type: {
                    asset_class: a.assetType.assetClass,
                    contract: a.assetType.contract,
                    token_id: new bignumber_js_1.default(a.assetType.tokenId),
                },
                value: new bignumber_js_1.default(a.value),
            };
        default: throw new Error("Unknown Asset Class");
    }
}
exports.covertToLibAsset = covertToLibAsset;
function convertTezosToUnionAsset(assetType) {
    switch (assetType.assetClass) {
        case "XTZ": {
            return { "@type": "XTZ" };
        }
        case "FT": {
            return {
                "@type": "TEZOS_FT",
                contract: convertTezosToContractAddress(assetType.contract),
                tokenId: assetType.tokenId ? (0, big_number_1.toBigNumber)(assetType.tokenId) : undefined,
            };
        }
        case "NFT": {
            return {
                "@type": "TEZOS_NFT",
                contract: convertTezosToContractAddress(assetType.contract),
                tokenId: (0, big_number_1.toBigNumber)(assetType.tokenId),
            };
        }
        case "MT": {
            return {
                "@type": "TEZOS_MT",
                contract: convertTezosToContractAddress(assetType.contract),
                tokenId: (0, big_number_1.toBigNumber)(assetType.tokenId),
            };
        }
        default: {
            throw new Error("Invalid asset type");
        }
    }
}
exports.convertTezosToUnionAsset = convertTezosToUnionAsset;
function convertOrderPayout(payout) {
    return (payout === null || payout === void 0 ? void 0 : payout.map(function (p) { return ({
        account: getTezosAddress(p.account),
        value: new bignumber_js_1.default(p.value),
    }); })) || [];
}
exports.convertOrderPayout = convertOrderPayout;
function convertFromContractAddress(contract) {
    var _a = tslib_1.__read(contract.split(":"), 2), blockchain = _a[0], tezosAddress = _a[1];
    if (blockchain !== api_client_1.Blockchain.TEZOS) {
        throw new Error("Not a tezos contract address: ".concat(contract));
    }
    return tezosAddress;
}
exports.convertFromContractAddress = convertFromContractAddress;
function convertUnionAddress(address) {
    var _a = tslib_1.__read(address.split(":"), 2), blockchain = _a[0], tezosAddress = _a[1];
    if (blockchain !== api_client_1.Blockchain.TEZOS) {
        throw new Error("Not a tezos address: ".concat(address));
    }
    return tezosAddress;
}
exports.convertUnionAddress = convertUnionAddress;
function convertTezosOrderId(hash) {
    return (0, types_1.toOrderId)("".concat(api_client_1.Blockchain.TEZOS, ":").concat(hash));
}
exports.convertTezosOrderId = convertTezosOrderId;
function convertTezosItemId(itemId) {
    return (0, types_1.toItemId)("".concat(api_client_1.Blockchain.TEZOS, ":").concat(itemId));
}
exports.convertTezosItemId = convertTezosItemId;
function convertTezosToContractAddress(address) {
    return (0, types_1.toContractAddress)("".concat(api_client_1.Blockchain.TEZOS, ":").concat(address));
}
exports.convertTezosToContractAddress = convertTezosToContractAddress;
function convertTezosToCollectionAddress(address) {
    return (0, types_1.toCollectionId)("".concat(api_client_1.Blockchain.TEZOS, ":").concat(address));
}
exports.convertTezosToCollectionAddress = convertTezosToCollectionAddress;
function convertTezosToUnionAddress(address) {
    return (0, types_1.toUnionAddress)("".concat(api_client_1.Blockchain.TEZOS, ":").concat(address));
}
exports.convertTezosToUnionAddress = convertTezosToUnionAddress;
